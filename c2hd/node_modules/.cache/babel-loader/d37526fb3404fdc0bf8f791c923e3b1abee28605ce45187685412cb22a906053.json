{"ast":null,"code":"'use strict';\n\nconst util = require('util');\nconst braces = require('braces');\nconst picomatch = require('picomatch');\nconst utils = require('picomatch/lib/utils');\nconst isEmptyString = val => val === '' || val === './';\n\n/**\r\n * Returns an array of strings that match one or more glob patterns.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm(list, patterns[, options]);\r\n *\r\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\r\n * //=> [ 'a.js' ]\r\n * ```\r\n * @param {String|Array<string>} `list` List of strings to match.\r\n * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options)\r\n * @return {Array} Returns an array of matches\r\n * @summary false\r\n * @api public\r\n */\n\nconst micromatch = (list, patterns, options) => {\n  patterns = [].concat(patterns);\n  list = [].concat(list);\n  let omit = new Set();\n  let keep = new Set();\n  let items = new Set();\n  let negatives = 0;\n  let onResult = state => {\n    items.add(state.output);\n    if (options && options.onResult) {\n      options.onResult(state);\n    }\n  };\n  for (let i = 0; i < patterns.length; i++) {\n    let isMatch = picomatch(String(patterns[i]), {\n      ...options,\n      onResult\n    }, true);\n    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n    if (negated) negatives++;\n    for (let item of list) {\n      let matched = isMatch(item, true);\n      let match = negated ? !matched.isMatch : matched.isMatch;\n      if (!match) continue;\n      if (negated) {\n        omit.add(matched.output);\n      } else {\n        omit.delete(matched.output);\n        keep.add(matched.output);\n      }\n    }\n  }\n  let result = negatives === patterns.length ? [...items] : [...keep];\n  let matches = result.filter(item => !omit.has(item));\n  if (options && matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\n    }\n    if (options.nonull === true || options.nullglob === true) {\n      return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\n    }\n  }\n  return matches;\n};\n\n/**\r\n * Backwards compatibility\r\n */\n\nmicromatch.match = micromatch;\n\n/**\r\n * Returns a matcher function from the given glob `pattern` and `options`.\r\n * The returned function takes a string to match as its only argument and returns\r\n * true if the string is a match.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.matcher(pattern[, options]);\r\n *\r\n * const isMatch = mm.matcher('*.!(*a)');\r\n * console.log(isMatch('a.a')); //=> false\r\n * console.log(isMatch('a.b')); //=> true\r\n * ```\r\n * @param {String} `pattern` Glob pattern\r\n * @param {Object} `options`\r\n * @return {Function} Returns a matcher function.\r\n * @api public\r\n */\n\nmicromatch.matcher = (pattern, options) => picomatch(pattern, options);\n\n/**\r\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.isMatch(string, patterns[, options]);\r\n *\r\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\r\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\r\n * ```\r\n * @param {String} `str` The string to test.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `[options]` See available [options](#options).\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\n\nmicromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\r\n * Backwards compatibility\r\n */\n\nmicromatch.any = micromatch.isMatch;\n\n/**\r\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.not(list, patterns[, options]);\r\n *\r\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\r\n * //=> ['b.b', 'c.c']\r\n * ```\r\n * @param {Array} `list` Array of strings to match.\r\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\r\n * @api public\r\n */\n\nmicromatch.not = function (list, patterns) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  patterns = [].concat(patterns).map(String);\n  let result = new Set();\n  let items = [];\n  let onResult = state => {\n    if (options.onResult) options.onResult(state);\n    items.push(state.output);\n  };\n  let matches = new Set(micromatch(list, patterns, {\n    ...options,\n    onResult\n  }));\n  for (let item of items) {\n    if (!matches.has(item)) {\n      result.add(item);\n    }\n  }\n  return [...result];\n};\n\n/**\r\n * Returns true if the given `string` contains the given pattern. Similar\r\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\r\n *\r\n * ```js\r\n * var mm = require('micromatch');\r\n * // mm.contains(string, pattern[, options]);\r\n *\r\n * console.log(mm.contains('aa/bb/cc', '*b'));\r\n * //=> true\r\n * console.log(mm.contains('aa/bb/cc', '*d'));\r\n * //=> false\r\n * ```\r\n * @param {String} `str` The string to match.\r\n * @param {String|Array} `patterns` Glob pattern to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any of the patterns matches any part of `str`.\r\n * @api public\r\n */\n\nmicromatch.contains = (str, pattern, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n  if (Array.isArray(pattern)) {\n    return pattern.some(p => micromatch.contains(str, p, options));\n  }\n  if (typeof pattern === 'string') {\n    if (isEmptyString(str) || isEmptyString(pattern)) {\n      return false;\n    }\n    if (str.includes(pattern) || str.startsWith('./') && str.slice(2).includes(pattern)) {\n      return true;\n    }\n  }\n  return micromatch.isMatch(str, pattern, {\n    ...options,\n    contains: true\n  });\n};\n\n/**\r\n * Filter the keys of the given object with the given `glob` pattern\r\n * and `options`. Does not attempt to match nested keys. If you need this feature,\r\n * use [glob-object][] instead.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.matchKeys(object, patterns[, options]);\r\n *\r\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\r\n * console.log(mm.matchKeys(obj, '*b'));\r\n * //=> { ab: 'b' }\r\n * ```\r\n * @param {Object} `object` The object with keys to filter.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Object} Returns an object with only keys that match the given patterns.\r\n * @api public\r\n */\n\nmicromatch.matchKeys = (obj, patterns, options) => {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('Expected the first argument to be an object');\n  }\n  let keys = micromatch(Object.keys(obj), patterns, options);\n  let res = {};\n  for (let key of keys) res[key] = obj[key];\n  return res;\n};\n\n/**\r\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.some(list, patterns[, options]);\r\n *\r\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\r\n * // true\r\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\r\n * // false\r\n * ```\r\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`\r\n * @api public\r\n */\n\nmicromatch.some = (list, patterns, options) => {\n  let items = [].concat(list);\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n    if (items.some(item => isMatch(item))) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\r\n * Returns true if every string in the given `list` matches\r\n * any of the given glob `patterns`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.every(list, patterns[, options]);\r\n *\r\n * console.log(mm.every('foo.js', ['foo.js']));\r\n * // true\r\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\r\n * // true\r\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\r\n * // false\r\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\r\n * // false\r\n * ```\r\n * @param {String|Array} `list` The string or array of strings to test.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`\r\n * @api public\r\n */\n\nmicromatch.every = (list, patterns, options) => {\n  let items = [].concat(list);\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n    if (!items.every(item => isMatch(item))) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\r\n * Returns true if **all** of the given `patterns` match\r\n * the specified string.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.all(string, patterns[, options]);\r\n *\r\n * console.log(mm.all('foo.js', ['foo.js']));\r\n * // true\r\n *\r\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\r\n * // false\r\n *\r\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\r\n * // true\r\n *\r\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\r\n * // true\r\n * ```\r\n * @param {String|Array} `str` The string to test.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\n\nmicromatch.all = (str, patterns, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n  return [].concat(patterns).every(p => picomatch(p, options)(str));\n};\n\n/**\r\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.capture(pattern, string[, options]);\r\n *\r\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\r\n * //=> ['foo']\r\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\r\n * //=> null\r\n * ```\r\n * @param {String} `glob` Glob pattern to use for matching.\r\n * @param {String} `input` String to match\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\r\n * @api public\r\n */\n\nmicromatch.capture = (glob, input, options) => {\n  let posix = utils.isWindows(options);\n  let regex = picomatch.makeRe(String(glob), {\n    ...options,\n    capture: true\n  });\n  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\n  if (match) {\n    return match.slice(1).map(v => v === void 0 ? '' : v);\n  }\n};\n\n/**\r\n * Create a regular expression from the given glob `pattern`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.makeRe(pattern[, options]);\r\n *\r\n * console.log(mm.makeRe('*.js'));\r\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\r\n * ```\r\n * @param {String} `pattern` A glob pattern to convert to regex.\r\n * @param {Object} `options`\r\n * @return {RegExp} Returns a regex created from the given pattern.\r\n * @api public\r\n */\n\nmicromatch.makeRe = function () {\n  return picomatch.makeRe(...arguments);\n};\n\n/**\r\n * Scan a glob pattern to separate the pattern into segments. Used\r\n * by the [split](#split) method.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * const state = mm.scan(pattern[, options]);\r\n * ```\r\n * @param {String} `pattern`\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object with\r\n * @api public\r\n */\n\nmicromatch.scan = function () {\n  return picomatch.scan(...arguments);\n};\n\n/**\r\n * Parse a glob pattern to create the source string for a regular\r\n * expression.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * const state = mm.parse(pattern[, options]);\r\n * ```\r\n * @param {String} `glob`\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\r\n * @api public\r\n */\n\nmicromatch.parse = (patterns, options) => {\n  let res = [];\n  for (let pattern of [].concat(patterns || [])) {\n    for (let str of braces(String(pattern), options)) {\n      res.push(picomatch.parse(str, options));\n    }\n  }\n  return res;\n};\n\n/**\r\n * Process the given brace `pattern`.\r\n *\r\n * ```js\r\n * const { braces } = require('micromatch');\r\n * console.log(braces('foo/{a,b,c}/bar'));\r\n * //=> [ 'foo/(a|b|c)/bar' ]\r\n *\r\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\r\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\r\n * ```\r\n * @param {String} `pattern` String with brace pattern to process.\r\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\r\n * @return {Array}\r\n * @api public\r\n */\n\nmicromatch.braces = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  if (options && options.nobrace === true || !/\\{.*\\}/.test(pattern)) {\n    return [pattern];\n  }\n  return braces(pattern, options);\n};\n\n/**\r\n * Expand braces\r\n */\n\nmicromatch.braceExpand = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  return micromatch.braces(pattern, {\n    ...options,\n    expand: true\n  });\n};\n\n/**\r\n * Expose micromatch\r\n */\n\nmodule.exports = micromatch;","map":{"version":3,"names":["util","require","braces","picomatch","utils","isEmptyString","val","micromatch","list","patterns","options","concat","omit","Set","keep","items","negatives","onResult","state","add","output","i","length","isMatch","String","negated","negatedExtglob","item","matched","match","delete","result","matches","filter","has","failglob","Error","join","nonull","nullglob","unescape","map","p","replace","matcher","pattern","str","any","not","push","contains","TypeError","inspect","Array","isArray","some","includes","startsWith","slice","matchKeys","obj","isObject","keys","Object","res","key","every","all","capture","glob","input","posix","isWindows","regex","makeRe","exec","toPosixSlashes","v","scan","parse","nobrace","test","braceExpand","expand","module","exports"],"sources":["D:/Documents/VS Code Projects/c2hd/c2hd/node_modules/micromatch/index.js"],"sourcesContent":["'use strict';\r\n\r\nconst util = require('util');\r\nconst braces = require('braces');\r\nconst picomatch = require('picomatch');\r\nconst utils = require('picomatch/lib/utils');\r\nconst isEmptyString = val => val === '' || val === './';\r\n\r\n/**\r\n * Returns an array of strings that match one or more glob patterns.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm(list, patterns[, options]);\r\n *\r\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\r\n * //=> [ 'a.js' ]\r\n * ```\r\n * @param {String|Array<string>} `list` List of strings to match.\r\n * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options)\r\n * @return {Array} Returns an array of matches\r\n * @summary false\r\n * @api public\r\n */\r\n\r\nconst micromatch = (list, patterns, options) => {\r\n  patterns = [].concat(patterns);\r\n  list = [].concat(list);\r\n\r\n  let omit = new Set();\r\n  let keep = new Set();\r\n  let items = new Set();\r\n  let negatives = 0;\r\n\r\n  let onResult = state => {\r\n    items.add(state.output);\r\n    if (options && options.onResult) {\r\n      options.onResult(state);\r\n    }\r\n  };\r\n\r\n  for (let i = 0; i < patterns.length; i++) {\r\n    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);\r\n    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\r\n    if (negated) negatives++;\r\n\r\n    for (let item of list) {\r\n      let matched = isMatch(item, true);\r\n\r\n      let match = negated ? !matched.isMatch : matched.isMatch;\r\n      if (!match) continue;\r\n\r\n      if (negated) {\r\n        omit.add(matched.output);\r\n      } else {\r\n        omit.delete(matched.output);\r\n        keep.add(matched.output);\r\n      }\r\n    }\r\n  }\r\n\r\n  let result = negatives === patterns.length ? [...items] : [...keep];\r\n  let matches = result.filter(item => !omit.has(item));\r\n\r\n  if (options && matches.length === 0) {\r\n    if (options.failglob === true) {\r\n      throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\r\n    }\r\n\r\n    if (options.nonull === true || options.nullglob === true) {\r\n      return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\r\n    }\r\n  }\r\n\r\n  return matches;\r\n};\r\n\r\n/**\r\n * Backwards compatibility\r\n */\r\n\r\nmicromatch.match = micromatch;\r\n\r\n/**\r\n * Returns a matcher function from the given glob `pattern` and `options`.\r\n * The returned function takes a string to match as its only argument and returns\r\n * true if the string is a match.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.matcher(pattern[, options]);\r\n *\r\n * const isMatch = mm.matcher('*.!(*a)');\r\n * console.log(isMatch('a.a')); //=> false\r\n * console.log(isMatch('a.b')); //=> true\r\n * ```\r\n * @param {String} `pattern` Glob pattern\r\n * @param {Object} `options`\r\n * @return {Function} Returns a matcher function.\r\n * @api public\r\n */\r\n\r\nmicromatch.matcher = (pattern, options) => picomatch(pattern, options);\r\n\r\n/**\r\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.isMatch(string, patterns[, options]);\r\n *\r\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\r\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\r\n * ```\r\n * @param {String} `str` The string to test.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `[options]` See available [options](#options).\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\r\n\r\nmicromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\r\n\r\n/**\r\n * Backwards compatibility\r\n */\r\n\r\nmicromatch.any = micromatch.isMatch;\r\n\r\n/**\r\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.not(list, patterns[, options]);\r\n *\r\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\r\n * //=> ['b.b', 'c.c']\r\n * ```\r\n * @param {Array} `list` Array of strings to match.\r\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\r\n * @api public\r\n */\r\n\r\nmicromatch.not = (list, patterns, options = {}) => {\r\n  patterns = [].concat(patterns).map(String);\r\n  let result = new Set();\r\n  let items = [];\r\n\r\n  let onResult = state => {\r\n    if (options.onResult) options.onResult(state);\r\n    items.push(state.output);\r\n  };\r\n\r\n  let matches = new Set(micromatch(list, patterns, { ...options, onResult }));\r\n\r\n  for (let item of items) {\r\n    if (!matches.has(item)) {\r\n      result.add(item);\r\n    }\r\n  }\r\n  return [...result];\r\n};\r\n\r\n/**\r\n * Returns true if the given `string` contains the given pattern. Similar\r\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\r\n *\r\n * ```js\r\n * var mm = require('micromatch');\r\n * // mm.contains(string, pattern[, options]);\r\n *\r\n * console.log(mm.contains('aa/bb/cc', '*b'));\r\n * //=> true\r\n * console.log(mm.contains('aa/bb/cc', '*d'));\r\n * //=> false\r\n * ```\r\n * @param {String} `str` The string to match.\r\n * @param {String|Array} `patterns` Glob pattern to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any of the patterns matches any part of `str`.\r\n * @api public\r\n */\r\n\r\nmicromatch.contains = (str, pattern, options) => {\r\n  if (typeof str !== 'string') {\r\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\r\n  }\r\n\r\n  if (Array.isArray(pattern)) {\r\n    return pattern.some(p => micromatch.contains(str, p, options));\r\n  }\r\n\r\n  if (typeof pattern === 'string') {\r\n    if (isEmptyString(str) || isEmptyString(pattern)) {\r\n      return false;\r\n    }\r\n\r\n    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return micromatch.isMatch(str, pattern, { ...options, contains: true });\r\n};\r\n\r\n/**\r\n * Filter the keys of the given object with the given `glob` pattern\r\n * and `options`. Does not attempt to match nested keys. If you need this feature,\r\n * use [glob-object][] instead.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.matchKeys(object, patterns[, options]);\r\n *\r\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\r\n * console.log(mm.matchKeys(obj, '*b'));\r\n * //=> { ab: 'b' }\r\n * ```\r\n * @param {Object} `object` The object with keys to filter.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Object} Returns an object with only keys that match the given patterns.\r\n * @api public\r\n */\r\n\r\nmicromatch.matchKeys = (obj, patterns, options) => {\r\n  if (!utils.isObject(obj)) {\r\n    throw new TypeError('Expected the first argument to be an object');\r\n  }\r\n  let keys = micromatch(Object.keys(obj), patterns, options);\r\n  let res = {};\r\n  for (let key of keys) res[key] = obj[key];\r\n  return res;\r\n};\r\n\r\n/**\r\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.some(list, patterns[, options]);\r\n *\r\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\r\n * // true\r\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\r\n * // false\r\n * ```\r\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`\r\n * @api public\r\n */\r\n\r\nmicromatch.some = (list, patterns, options) => {\r\n  let items = [].concat(list);\r\n\r\n  for (let pattern of [].concat(patterns)) {\r\n    let isMatch = picomatch(String(pattern), options);\r\n    if (items.some(item => isMatch(item))) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Returns true if every string in the given `list` matches\r\n * any of the given glob `patterns`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.every(list, patterns[, options]);\r\n *\r\n * console.log(mm.every('foo.js', ['foo.js']));\r\n * // true\r\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\r\n * // true\r\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\r\n * // false\r\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\r\n * // false\r\n * ```\r\n * @param {String|Array} `list` The string or array of strings to test.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`\r\n * @api public\r\n */\r\n\r\nmicromatch.every = (list, patterns, options) => {\r\n  let items = [].concat(list);\r\n\r\n  for (let pattern of [].concat(patterns)) {\r\n    let isMatch = picomatch(String(pattern), options);\r\n    if (!items.every(item => isMatch(item))) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * Returns true if **all** of the given `patterns` match\r\n * the specified string.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.all(string, patterns[, options]);\r\n *\r\n * console.log(mm.all('foo.js', ['foo.js']));\r\n * // true\r\n *\r\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\r\n * // false\r\n *\r\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\r\n * // true\r\n *\r\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\r\n * // true\r\n * ```\r\n * @param {String|Array} `str` The string to test.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\r\n\r\nmicromatch.all = (str, patterns, options) => {\r\n  if (typeof str !== 'string') {\r\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\r\n  }\r\n\r\n  return [].concat(patterns).every(p => picomatch(p, options)(str));\r\n};\r\n\r\n/**\r\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.capture(pattern, string[, options]);\r\n *\r\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\r\n * //=> ['foo']\r\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\r\n * //=> null\r\n * ```\r\n * @param {String} `glob` Glob pattern to use for matching.\r\n * @param {String} `input` String to match\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\r\n * @api public\r\n */\r\n\r\nmicromatch.capture = (glob, input, options) => {\r\n  let posix = utils.isWindows(options);\r\n  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });\r\n  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\r\n\r\n  if (match) {\r\n    return match.slice(1).map(v => v === void 0 ? '' : v);\r\n  }\r\n};\r\n\r\n/**\r\n * Create a regular expression from the given glob `pattern`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.makeRe(pattern[, options]);\r\n *\r\n * console.log(mm.makeRe('*.js'));\r\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\r\n * ```\r\n * @param {String} `pattern` A glob pattern to convert to regex.\r\n * @param {Object} `options`\r\n * @return {RegExp} Returns a regex created from the given pattern.\r\n * @api public\r\n */\r\n\r\nmicromatch.makeRe = (...args) => picomatch.makeRe(...args);\r\n\r\n/**\r\n * Scan a glob pattern to separate the pattern into segments. Used\r\n * by the [split](#split) method.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * const state = mm.scan(pattern[, options]);\r\n * ```\r\n * @param {String} `pattern`\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object with\r\n * @api public\r\n */\r\n\r\nmicromatch.scan = (...args) => picomatch.scan(...args);\r\n\r\n/**\r\n * Parse a glob pattern to create the source string for a regular\r\n * expression.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * const state = mm.parse(pattern[, options]);\r\n * ```\r\n * @param {String} `glob`\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\r\n * @api public\r\n */\r\n\r\nmicromatch.parse = (patterns, options) => {\r\n  let res = [];\r\n  for (let pattern of [].concat(patterns || [])) {\r\n    for (let str of braces(String(pattern), options)) {\r\n      res.push(picomatch.parse(str, options));\r\n    }\r\n  }\r\n  return res;\r\n};\r\n\r\n/**\r\n * Process the given brace `pattern`.\r\n *\r\n * ```js\r\n * const { braces } = require('micromatch');\r\n * console.log(braces('foo/{a,b,c}/bar'));\r\n * //=> [ 'foo/(a|b|c)/bar' ]\r\n *\r\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\r\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\r\n * ```\r\n * @param {String} `pattern` String with brace pattern to process.\r\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nmicromatch.braces = (pattern, options) => {\r\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\r\n  if ((options && options.nobrace === true) || !/\\{.*\\}/.test(pattern)) {\r\n    return [pattern];\r\n  }\r\n  return braces(pattern, options);\r\n};\r\n\r\n/**\r\n * Expand braces\r\n */\r\n\r\nmicromatch.braceExpand = (pattern, options) => {\r\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\r\n  return micromatch.braces(pattern, { ...options, expand: true });\r\n};\r\n\r\n/**\r\n * Expose micromatch\r\n */\r\n\r\nmodule.exports = micromatch;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}