{"ast":null,"code":"var common = exports,\n  url = require('url'),\n  extend = require('util')._extend,\n  required = require('requires-port');\nvar upgradeHeader = /(^|,)\\s*upgrade\\s*($|,)/i,\n  isSSL = /^https|wss/;\n\n/**\r\n * Simple Regex for testing if protocol is https\r\n */\ncommon.isSSL = isSSL;\n/**\r\n * Copies the right headers from `options` and `req` to\r\n * `outgoing` which is then used to fire the proxied\r\n * request.\r\n *\r\n * Examples:\r\n *\r\n *    common.setupOutgoing(outgoing, options, req)\r\n *    // => { host: ..., hostname: ...}\r\n *\r\n * @param {Object} Outgoing Base object to be filled with required properties\r\n * @param {Object} Options Config object passed to the proxy\r\n * @param {ClientRequest} Req Request Object\r\n * @param {String} Forward String to select forward or target\r\n * \r\n * @return {Object} Outgoing Object with all required properties set\r\n *\r\n * @api private\r\n */\n\ncommon.setupOutgoing = function (outgoing, options, req, forward) {\n  outgoing.port = options[forward || 'target'].port || (isSSL.test(options[forward || 'target'].protocol) ? 443 : 80);\n  ['host', 'hostname', 'socketPath', 'pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'secureProtocol'].forEach(function (e) {\n    outgoing[e] = options[forward || 'target'][e];\n  });\n  outgoing.method = options.method || req.method;\n  outgoing.headers = extend({}, req.headers);\n  if (options.headers) {\n    extend(outgoing.headers, options.headers);\n  }\n  if (options.auth) {\n    outgoing.auth = options.auth;\n  }\n  if (options.ca) {\n    outgoing.ca = options.ca;\n  }\n  if (isSSL.test(options[forward || 'target'].protocol)) {\n    outgoing.rejectUnauthorized = typeof options.secure === \"undefined\" ? true : options.secure;\n  }\n  outgoing.agent = options.agent || false;\n  outgoing.localAddress = options.localAddress;\n\n  //\n  // Remark: If we are false and not upgrading, set the connection: close. This is the right thing to do\n  // as node core doesn't handle this COMPLETELY properly yet.\n  //\n  if (!outgoing.agent) {\n    outgoing.headers = outgoing.headers || {};\n    if (typeof outgoing.headers.connection !== 'string' || !upgradeHeader.test(outgoing.headers.connection)) {\n      outgoing.headers.connection = 'close';\n    }\n  }\n\n  // the final path is target path + relative path requested by user:\n  var target = options[forward || 'target'];\n  var targetPath = target && options.prependPath !== false ? target.path || '' : '';\n\n  //\n  // Remark: Can we somehow not use url.parse as a perf optimization?\n  //\n  var outgoingPath = !options.toProxy ? url.parse(req.url).path || '' : req.url;\n\n  //\n  // Remark: ignorePath will just straight up ignore whatever the request's\n  // path is. This can be labeled as FOOT-GUN material if you do not know what\n  // you are doing and are using conflicting options.\n  //\n  outgoingPath = !options.ignorePath ? outgoingPath : '';\n  outgoing.path = common.urlJoin(targetPath, outgoingPath);\n  if (options.changeOrigin) {\n    outgoing.headers.host = required(outgoing.port, options[forward || 'target'].protocol) && !hasPort(outgoing.host) ? outgoing.host + ':' + outgoing.port : outgoing.host;\n  }\n  return outgoing;\n};\n\n/**\r\n * Set the proper configuration for sockets,\r\n * set no delay and set keep alive, also set\r\n * the timeout to 0.\r\n *\r\n * Examples:\r\n *\r\n *    common.setupSocket(socket)\r\n *    // => Socket\r\n *\r\n * @param {Socket} Socket instance to setup\r\n * \r\n * @return {Socket} Return the configured socket.\r\n *\r\n * @api private\r\n */\n\ncommon.setupSocket = function (socket) {\n  socket.setTimeout(0);\n  socket.setNoDelay(true);\n  socket.setKeepAlive(true, 0);\n  return socket;\n};\n\n/**\r\n * Get the port number from the host. Or guess it based on the connection type.\r\n *\r\n * @param {Request} req Incoming HTTP request.\r\n *\r\n * @return {String} The port number.\r\n *\r\n * @api private\r\n */\ncommon.getPort = function (req) {\n  var res = req.headers.host ? req.headers.host.match(/:(\\d+)/) : '';\n  return res ? res[1] : common.hasEncryptedConnection(req) ? '443' : '80';\n};\n\n/**\r\n * Check if the request has an encrypted connection.\r\n *\r\n * @param {Request} req Incoming HTTP request.\r\n *\r\n * @return {Boolean} Whether the connection is encrypted or not.\r\n *\r\n * @api private\r\n */\ncommon.hasEncryptedConnection = function (req) {\n  return Boolean(req.connection.encrypted || req.connection.pair);\n};\n\n/**\r\n * OS-agnostic join (doesn't break on URLs like path.join does on Windows)>\r\n *\r\n * @return {String} The generated path.\r\n *\r\n * @api private\r\n */\n\ncommon.urlJoin = function () {\n  //\n  // We do not want to mess with the query string. All we want to touch is the path.\n  //\n  var args = Array.prototype.slice.call(arguments),\n    lastIndex = args.length - 1,\n    last = args[lastIndex],\n    lastSegs = last.split('?'),\n    retSegs;\n  args[lastIndex] = lastSegs.shift();\n\n  //\n  // Join all strings, but remove empty strings so we don't get extra slashes from\n  // joining e.g. ['', 'am']\n  //\n  retSegs = [args.filter(Boolean).join('/').replace(/\\/+/g, '/').replace('http:/', 'http://').replace('https:/', 'https://')];\n\n  // Only join the query string if it exists so we don't have trailing a '?'\n  // on every request\n\n  // Handle case where there could be multiple ? in the URL.\n  retSegs.push.apply(retSegs, lastSegs);\n  return retSegs.join('?');\n};\n\n/**\r\n * Rewrites or removes the domain of a cookie header\r\n *\r\n * @param {String|Array} Header\r\n * @param {Object} Config, mapping of domain to rewritten domain.\r\n *                 '*' key to match any domain, null value to remove the domain.\r\n *\r\n * @api private\r\n */\ncommon.rewriteCookieProperty = function rewriteCookieProperty(header, config, property) {\n  if (Array.isArray(header)) {\n    return header.map(function (headerElement) {\n      return rewriteCookieProperty(headerElement, config, property);\n    });\n  }\n  return header.replace(new RegExp(\"(;\\\\s*\" + property + \"=)([^;]+)\", 'i'), function (match, prefix, previousValue) {\n    var newValue;\n    if (previousValue in config) {\n      newValue = config[previousValue];\n    } else if ('*' in config) {\n      newValue = config['*'];\n    } else {\n      //no match, return previous value\n      return match;\n    }\n    if (newValue) {\n      //replace value\n      return prefix + newValue;\n    } else {\n      //remove value\n      return '';\n    }\n  });\n};\n\n/**\r\n * Check the host and see if it potentially has a port in it (keep it simple)\r\n *\r\n * @returns {Boolean} Whether we have one or not\r\n *\r\n * @api private\r\n */\nfunction hasPort(host) {\n  return !!~host.indexOf(':');\n}\n;","map":{"version":3,"names":["common","exports","url","require","extend","_extend","required","upgradeHeader","isSSL","setupOutgoing","outgoing","options","req","forward","port","test","protocol","forEach","e","method","headers","auth","ca","rejectUnauthorized","secure","agent","localAddress","connection","target","targetPath","prependPath","path","outgoingPath","toProxy","parse","ignorePath","urlJoin","changeOrigin","host","hasPort","setupSocket","socket","setTimeout","setNoDelay","setKeepAlive","getPort","res","match","hasEncryptedConnection","Boolean","encrypted","pair","args","Array","prototype","slice","call","arguments","lastIndex","length","last","lastSegs","split","retSegs","shift","filter","join","replace","push","apply","rewriteCookieProperty","header","config","property","isArray","map","headerElement","RegExp","prefix","previousValue","newValue","indexOf"],"sources":["D:/Documents/VS Code Projects/c2hd/c2hd/node_modules/http-proxy/lib/http-proxy/common.js"],"sourcesContent":["var common   = exports,\r\n    url      = require('url'),\r\n    extend   = require('util')._extend,\r\n    required = require('requires-port');\r\n\r\nvar upgradeHeader = /(^|,)\\s*upgrade\\s*($|,)/i,\r\n    isSSL = /^https|wss/;\r\n\r\n/**\r\n * Simple Regex for testing if protocol is https\r\n */\r\ncommon.isSSL = isSSL;\r\n/**\r\n * Copies the right headers from `options` and `req` to\r\n * `outgoing` which is then used to fire the proxied\r\n * request.\r\n *\r\n * Examples:\r\n *\r\n *    common.setupOutgoing(outgoing, options, req)\r\n *    // => { host: ..., hostname: ...}\r\n *\r\n * @param {Object} Outgoing Base object to be filled with required properties\r\n * @param {Object} Options Config object passed to the proxy\r\n * @param {ClientRequest} Req Request Object\r\n * @param {String} Forward String to select forward or target\r\n * \r\n * @return {Object} Outgoing Object with all required properties set\r\n *\r\n * @api private\r\n */\r\n\r\ncommon.setupOutgoing = function(outgoing, options, req, forward) {\r\n  outgoing.port = options[forward || 'target'].port ||\r\n                  (isSSL.test(options[forward || 'target'].protocol) ? 443 : 80);\r\n\r\n  ['host', 'hostname', 'socketPath', 'pfx', 'key',\r\n    'passphrase', 'cert', 'ca', 'ciphers', 'secureProtocol'].forEach(\r\n    function(e) { outgoing[e] = options[forward || 'target'][e]; }\r\n  );\r\n\r\n  outgoing.method = options.method || req.method;\r\n  outgoing.headers = extend({}, req.headers);\r\n\r\n  if (options.headers){\r\n    extend(outgoing.headers, options.headers);\r\n  }\r\n\r\n  if (options.auth) {\r\n    outgoing.auth = options.auth;\r\n  }\r\n  \r\n  if (options.ca) {\r\n      outgoing.ca = options.ca;\r\n  }\r\n\r\n  if (isSSL.test(options[forward || 'target'].protocol)) {\r\n    outgoing.rejectUnauthorized = (typeof options.secure === \"undefined\") ? true : options.secure;\r\n  }\r\n\r\n\r\n  outgoing.agent = options.agent || false;\r\n  outgoing.localAddress = options.localAddress;\r\n\r\n  //\r\n  // Remark: If we are false and not upgrading, set the connection: close. This is the right thing to do\r\n  // as node core doesn't handle this COMPLETELY properly yet.\r\n  //\r\n  if (!outgoing.agent) {\r\n    outgoing.headers = outgoing.headers || {};\r\n    if (typeof outgoing.headers.connection !== 'string'\r\n        || !upgradeHeader.test(outgoing.headers.connection)\r\n       ) { outgoing.headers.connection = 'close'; }\r\n  }\r\n\r\n\r\n  // the final path is target path + relative path requested by user:\r\n  var target = options[forward || 'target'];\r\n  var targetPath = target && options.prependPath !== false\r\n    ? (target.path || '')\r\n    : '';\r\n\r\n  //\r\n  // Remark: Can we somehow not use url.parse as a perf optimization?\r\n  //\r\n  var outgoingPath = !options.toProxy\r\n    ? (url.parse(req.url).path || '')\r\n    : req.url;\r\n\r\n  //\r\n  // Remark: ignorePath will just straight up ignore whatever the request's\r\n  // path is. This can be labeled as FOOT-GUN material if you do not know what\r\n  // you are doing and are using conflicting options.\r\n  //\r\n  outgoingPath = !options.ignorePath ? outgoingPath : '';\r\n\r\n  outgoing.path = common.urlJoin(targetPath, outgoingPath);\r\n\r\n  if (options.changeOrigin) {\r\n    outgoing.headers.host =\r\n      required(outgoing.port, options[forward || 'target'].protocol) && !hasPort(outgoing.host)\r\n        ? outgoing.host + ':' + outgoing.port\r\n        : outgoing.host;\r\n  }\r\n  return outgoing;\r\n};\r\n\r\n/**\r\n * Set the proper configuration for sockets,\r\n * set no delay and set keep alive, also set\r\n * the timeout to 0.\r\n *\r\n * Examples:\r\n *\r\n *    common.setupSocket(socket)\r\n *    // => Socket\r\n *\r\n * @param {Socket} Socket instance to setup\r\n * \r\n * @return {Socket} Return the configured socket.\r\n *\r\n * @api private\r\n */\r\n\r\ncommon.setupSocket = function(socket) {\r\n  socket.setTimeout(0);\r\n  socket.setNoDelay(true);\r\n\r\n  socket.setKeepAlive(true, 0);\r\n\r\n  return socket;\r\n};\r\n\r\n/**\r\n * Get the port number from the host. Or guess it based on the connection type.\r\n *\r\n * @param {Request} req Incoming HTTP request.\r\n *\r\n * @return {String} The port number.\r\n *\r\n * @api private\r\n */\r\ncommon.getPort = function(req) {\r\n  var res = req.headers.host ? req.headers.host.match(/:(\\d+)/) : '';\r\n\r\n  return res ?\r\n    res[1] :\r\n    common.hasEncryptedConnection(req) ? '443' : '80';\r\n};\r\n\r\n/**\r\n * Check if the request has an encrypted connection.\r\n *\r\n * @param {Request} req Incoming HTTP request.\r\n *\r\n * @return {Boolean} Whether the connection is encrypted or not.\r\n *\r\n * @api private\r\n */\r\ncommon.hasEncryptedConnection = function(req) {\r\n  return Boolean(req.connection.encrypted || req.connection.pair);\r\n};\r\n\r\n/**\r\n * OS-agnostic join (doesn't break on URLs like path.join does on Windows)>\r\n *\r\n * @return {String} The generated path.\r\n *\r\n * @api private\r\n */\r\n\r\ncommon.urlJoin = function() {\r\n    //\r\n    // We do not want to mess with the query string. All we want to touch is the path.\r\n    //\r\n  var args = Array.prototype.slice.call(arguments),\r\n      lastIndex = args.length - 1,\r\n      last = args[lastIndex],\r\n      lastSegs = last.split('?'),\r\n      retSegs;\r\n\r\n  args[lastIndex] = lastSegs.shift();\r\n\r\n  //\r\n  // Join all strings, but remove empty strings so we don't get extra slashes from\r\n  // joining e.g. ['', 'am']\r\n  //\r\n  retSegs = [\r\n    args.filter(Boolean).join('/')\r\n        .replace(/\\/+/g, '/')\r\n        .replace('http:/', 'http://')\r\n        .replace('https:/', 'https://')\r\n  ];\r\n\r\n  // Only join the query string if it exists so we don't have trailing a '?'\r\n  // on every request\r\n\r\n  // Handle case where there could be multiple ? in the URL.\r\n  retSegs.push.apply(retSegs, lastSegs);\r\n\r\n  return retSegs.join('?')\r\n};\r\n\r\n/**\r\n * Rewrites or removes the domain of a cookie header\r\n *\r\n * @param {String|Array} Header\r\n * @param {Object} Config, mapping of domain to rewritten domain.\r\n *                 '*' key to match any domain, null value to remove the domain.\r\n *\r\n * @api private\r\n */\r\ncommon.rewriteCookieProperty = function rewriteCookieProperty(header, config, property) {\r\n  if (Array.isArray(header)) {\r\n    return header.map(function (headerElement) {\r\n      return rewriteCookieProperty(headerElement, config, property);\r\n    });\r\n  }\r\n  return header.replace(new RegExp(\"(;\\\\s*\" + property + \"=)([^;]+)\", 'i'), function(match, prefix, previousValue) {\r\n    var newValue;\r\n    if (previousValue in config) {\r\n      newValue = config[previousValue];\r\n    } else if ('*' in config) {\r\n      newValue = config['*'];\r\n    } else {\r\n      //no match, return previous value\r\n      return match;\r\n    }\r\n    if (newValue) {\r\n      //replace value\r\n      return prefix + newValue;\r\n    } else {\r\n      //remove value\r\n      return '';\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Check the host and see if it potentially has a port in it (keep it simple)\r\n *\r\n * @returns {Boolean} Whether we have one or not\r\n *\r\n * @api private\r\n */\r\nfunction hasPort(host) {\r\n  return !!~host.indexOf(':');\r\n};\r\n"],"mappings":"AAAA,IAAIA,MAAM,GAAKC,OAAO;EAClBC,GAAG,GAAQC,OAAO,CAAC,KAAK,CAAC;EACzBC,MAAM,GAAKD,OAAO,CAAC,MAAM,CAAC,CAACE,OAAO;EAClCC,QAAQ,GAAGH,OAAO,CAAC,eAAe,CAAC;AAEvC,IAAII,aAAa,GAAG,0BAA0B;EAC1CC,KAAK,GAAG,YAAY;;AAExB;AACA;AACA;AACAR,MAAM,CAACQ,KAAK,GAAGA,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAR,MAAM,CAACS,aAAa,GAAG,UAASC,QAAQ,EAAEC,OAAO,EAAEC,GAAG,EAAEC,OAAO,EAAE;EAC/DH,QAAQ,CAACI,IAAI,GAAGH,OAAO,CAACE,OAAO,IAAI,QAAQ,CAAC,CAACC,IAAI,KAChCN,KAAK,CAACO,IAAI,CAACJ,OAAO,CAACE,OAAO,IAAI,QAAQ,CAAC,CAACG,QAAQ,CAAC,GAAG,GAAG,GAAG,EAAE,CAAC;EAE9E,CAAC,MAAM,EAAE,UAAU,EAAE,YAAY,EAAE,KAAK,EAAE,KAAK,EAC7C,YAAY,EAAE,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,gBAAgB,CAAC,CAACC,OAAO,CAChE,UAASC,CAAC,EAAE;IAAER,QAAQ,CAACQ,CAAC,CAAC,GAAGP,OAAO,CAACE,OAAO,IAAI,QAAQ,CAAC,CAACK,CAAC,CAAC;EAAE,CAAC,CAC/D;EAEDR,QAAQ,CAACS,MAAM,GAAGR,OAAO,CAACQ,MAAM,IAAIP,GAAG,CAACO,MAAM;EAC9CT,QAAQ,CAACU,OAAO,GAAGhB,MAAM,CAAC,CAAC,CAAC,EAAEQ,GAAG,CAACQ,OAAO,CAAC;EAE1C,IAAIT,OAAO,CAACS,OAAO,EAAC;IAClBhB,MAAM,CAACM,QAAQ,CAACU,OAAO,EAAET,OAAO,CAACS,OAAO,CAAC;EAC3C;EAEA,IAAIT,OAAO,CAACU,IAAI,EAAE;IAChBX,QAAQ,CAACW,IAAI,GAAGV,OAAO,CAACU,IAAI;EAC9B;EAEA,IAAIV,OAAO,CAACW,EAAE,EAAE;IACZZ,QAAQ,CAACY,EAAE,GAAGX,OAAO,CAACW,EAAE;EAC5B;EAEA,IAAId,KAAK,CAACO,IAAI,CAACJ,OAAO,CAACE,OAAO,IAAI,QAAQ,CAAC,CAACG,QAAQ,CAAC,EAAE;IACrDN,QAAQ,CAACa,kBAAkB,GAAI,OAAOZ,OAAO,CAACa,MAAM,KAAK,WAAW,GAAI,IAAI,GAAGb,OAAO,CAACa,MAAM;EAC/F;EAGAd,QAAQ,CAACe,KAAK,GAAGd,OAAO,CAACc,KAAK,IAAI,KAAK;EACvCf,QAAQ,CAACgB,YAAY,GAAGf,OAAO,CAACe,YAAY;;EAE5C;EACA;EACA;EACA;EACA,IAAI,CAAChB,QAAQ,CAACe,KAAK,EAAE;IACnBf,QAAQ,CAACU,OAAO,GAAGV,QAAQ,CAACU,OAAO,IAAI,CAAC,CAAC;IACzC,IAAI,OAAOV,QAAQ,CAACU,OAAO,CAACO,UAAU,KAAK,QAAQ,IAC5C,CAACpB,aAAa,CAACQ,IAAI,CAACL,QAAQ,CAACU,OAAO,CAACO,UAAU,CAAC,EAClD;MAAEjB,QAAQ,CAACU,OAAO,CAACO,UAAU,GAAG,OAAO;IAAE;EAChD;;EAGA;EACA,IAAIC,MAAM,GAAGjB,OAAO,CAACE,OAAO,IAAI,QAAQ,CAAC;EACzC,IAAIgB,UAAU,GAAGD,MAAM,IAAIjB,OAAO,CAACmB,WAAW,KAAK,KAAK,GACnDF,MAAM,CAACG,IAAI,IAAI,EAAE,GAClB,EAAE;;EAEN;EACA;EACA;EACA,IAAIC,YAAY,GAAG,CAACrB,OAAO,CAACsB,OAAO,GAC9B/B,GAAG,CAACgC,KAAK,CAACtB,GAAG,CAACV,GAAG,CAAC,CAAC6B,IAAI,IAAI,EAAE,GAC9BnB,GAAG,CAACV,GAAG;;EAEX;EACA;EACA;EACA;EACA;EACA8B,YAAY,GAAG,CAACrB,OAAO,CAACwB,UAAU,GAAGH,YAAY,GAAG,EAAE;EAEtDtB,QAAQ,CAACqB,IAAI,GAAG/B,MAAM,CAACoC,OAAO,CAACP,UAAU,EAAEG,YAAY,CAAC;EAExD,IAAIrB,OAAO,CAAC0B,YAAY,EAAE;IACxB3B,QAAQ,CAACU,OAAO,CAACkB,IAAI,GACnBhC,QAAQ,CAACI,QAAQ,CAACI,IAAI,EAAEH,OAAO,CAACE,OAAO,IAAI,QAAQ,CAAC,CAACG,QAAQ,CAAC,IAAI,CAACuB,OAAO,CAAC7B,QAAQ,CAAC4B,IAAI,CAAC,GACrF5B,QAAQ,CAAC4B,IAAI,GAAG,GAAG,GAAG5B,QAAQ,CAACI,IAAI,GACnCJ,QAAQ,CAAC4B,IAAI;EACrB;EACA,OAAO5B,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAV,MAAM,CAACwC,WAAW,GAAG,UAASC,MAAM,EAAE;EACpCA,MAAM,CAACC,UAAU,CAAC,CAAC,CAAC;EACpBD,MAAM,CAACE,UAAU,CAAC,IAAI,CAAC;EAEvBF,MAAM,CAACG,YAAY,CAAC,IAAI,EAAE,CAAC,CAAC;EAE5B,OAAOH,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzC,MAAM,CAAC6C,OAAO,GAAG,UAASjC,GAAG,EAAE;EAC7B,IAAIkC,GAAG,GAAGlC,GAAG,CAACQ,OAAO,CAACkB,IAAI,GAAG1B,GAAG,CAACQ,OAAO,CAACkB,IAAI,CAACS,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE;EAElE,OAAOD,GAAG,GACRA,GAAG,CAAC,CAAC,CAAC,GACN9C,MAAM,CAACgD,sBAAsB,CAACpC,GAAG,CAAC,GAAG,KAAK,GAAG,IAAI;AACrD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAZ,MAAM,CAACgD,sBAAsB,GAAG,UAASpC,GAAG,EAAE;EAC5C,OAAOqC,OAAO,CAACrC,GAAG,CAACe,UAAU,CAACuB,SAAS,IAAItC,GAAG,CAACe,UAAU,CAACwB,IAAI,CAAC;AACjE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAnD,MAAM,CAACoC,OAAO,GAAG,YAAW;EACxB;EACA;EACA;EACF,IAAIgB,IAAI,GAAGC,KAAK,CAACC,SAAS,CAACC,KAAK,CAACC,IAAI,CAACC,SAAS,CAAC;IAC5CC,SAAS,GAAGN,IAAI,CAACO,MAAM,GAAG,CAAC;IAC3BC,IAAI,GAAGR,IAAI,CAACM,SAAS,CAAC;IACtBG,QAAQ,GAAGD,IAAI,CAACE,KAAK,CAAC,GAAG,CAAC;IAC1BC,OAAO;EAEXX,IAAI,CAACM,SAAS,CAAC,GAAGG,QAAQ,CAACG,KAAK,EAAE;;EAElC;EACA;EACA;EACA;EACAD,OAAO,GAAG,CACRX,IAAI,CAACa,MAAM,CAAChB,OAAO,CAAC,CAACiB,IAAI,CAAC,GAAG,CAAC,CACzBC,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CACpBA,OAAO,CAAC,QAAQ,EAAE,SAAS,CAAC,CAC5BA,OAAO,CAAC,SAAS,EAAE,UAAU,CAAC,CACpC;;EAED;EACA;;EAEA;EACAJ,OAAO,CAACK,IAAI,CAACC,KAAK,CAACN,OAAO,EAAEF,QAAQ,CAAC;EAErC,OAAOE,OAAO,CAACG,IAAI,CAAC,GAAG,CAAC;AAC1B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAlE,MAAM,CAACsE,qBAAqB,GAAG,SAASA,qBAAqB,CAACC,MAAM,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EACtF,IAAIpB,KAAK,CAACqB,OAAO,CAACH,MAAM,CAAC,EAAE;IACzB,OAAOA,MAAM,CAACI,GAAG,CAAC,UAAUC,aAAa,EAAE;MACzC,OAAON,qBAAqB,CAACM,aAAa,EAAEJ,MAAM,EAAEC,QAAQ,CAAC;IAC/D,CAAC,CAAC;EACJ;EACA,OAAOF,MAAM,CAACJ,OAAO,CAAC,IAAIU,MAAM,CAAC,QAAQ,GAAGJ,QAAQ,GAAG,WAAW,EAAE,GAAG,CAAC,EAAE,UAAS1B,KAAK,EAAE+B,MAAM,EAAEC,aAAa,EAAE;IAC/G,IAAIC,QAAQ;IACZ,IAAID,aAAa,IAAIP,MAAM,EAAE;MAC3BQ,QAAQ,GAAGR,MAAM,CAACO,aAAa,CAAC;IAClC,CAAC,MAAM,IAAI,GAAG,IAAIP,MAAM,EAAE;MACxBQ,QAAQ,GAAGR,MAAM,CAAC,GAAG,CAAC;IACxB,CAAC,MAAM;MACL;MACA,OAAOzB,KAAK;IACd;IACA,IAAIiC,QAAQ,EAAE;MACZ;MACA,OAAOF,MAAM,GAAGE,QAAQ;IAC1B,CAAC,MAAM;MACL;MACA,OAAO,EAAE;IACX;EACF,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASzC,OAAO,CAACD,IAAI,EAAE;EACrB,OAAO,CAAC,CAAC,CAACA,IAAI,CAAC2C,OAAO,CAAC,GAAG,CAAC;AAC7B;AAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}