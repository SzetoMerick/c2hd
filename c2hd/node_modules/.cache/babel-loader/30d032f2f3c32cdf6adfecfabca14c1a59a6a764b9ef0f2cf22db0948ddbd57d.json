{"ast":null,"code":"var http = require('http'),\n  https = require('https'),\n  common = require('../common');\n\n/*!\r\n * Array of passes.\r\n *\r\n * A `pass` is just a function that is executed on `req, socket, options`\r\n * so that you can easily add new checks while still keeping the base\r\n * flexible.\r\n */\n\n/*\r\n * Websockets Passes\r\n *\r\n */\n\nmodule.exports = {\n  /**\r\n   * WebSocket requests must have the `GET` method and\r\n   * the `upgrade:websocket` header\r\n   *\r\n   * @param {ClientRequest} Req Request object\r\n   * @param {Socket} Websocket\r\n   *\r\n   * @api private\r\n   */\n\n  checkMethodAndHeader: function checkMethodAndHeader(req, socket) {\n    if (req.method !== 'GET' || !req.headers.upgrade) {\n      socket.destroy();\n      return true;\n    }\n    if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n      socket.destroy();\n      return true;\n    }\n  },\n  /**\r\n   * Sets `x-forwarded-*` headers if specified in config.\r\n   *\r\n   * @param {ClientRequest} Req Request object\r\n   * @param {Socket} Websocket\r\n   * @param {Object} Options Config object passed to the proxy\r\n   *\r\n   * @api private\r\n   */\n\n  XHeaders: function XHeaders(req, socket, options) {\n    if (!options.xfwd) return;\n    var values = {\n      for: req.connection.remoteAddress || req.socket.remoteAddress,\n      port: common.getPort(req),\n      proto: common.hasEncryptedConnection(req) ? 'wss' : 'ws'\n    };\n    ['for', 'port', 'proto'].forEach(function (header) {\n      req.headers['x-forwarded-' + header] = (req.headers['x-forwarded-' + header] || '') + (req.headers['x-forwarded-' + header] ? ',' : '') + values[header];\n    });\n  },\n  /**\r\n   * Does the actual proxying. Make the request and upgrade it\r\n   * send the Switching Protocols request and pipe the sockets.\r\n   *\r\n   * @param {ClientRequest} Req Request object\r\n   * @param {Socket} Websocket\r\n   * @param {Object} Options Config object passed to the proxy\r\n   *\r\n   * @api private\r\n   */\n  stream: function stream(req, socket, options, head, server, clb) {\n    var createHttpHeader = function (line, headers) {\n      return Object.keys(headers).reduce(function (head, key) {\n        var value = headers[key];\n        if (!Array.isArray(value)) {\n          head.push(key + ': ' + value);\n          return head;\n        }\n        for (var i = 0; i < value.length; i++) {\n          head.push(key + ': ' + value[i]);\n        }\n        return head;\n      }, [line]).join('\\r\\n') + '\\r\\n\\r\\n';\n    };\n    common.setupSocket(socket);\n    if (head && head.length) socket.unshift(head);\n    var proxyReq = (common.isSSL.test(options.target.protocol) ? https : http).request(common.setupOutgoing(options.ssl || {}, options, req));\n\n    // Enable developers to modify the proxyReq before headers are sent\n    if (server) {\n      server.emit('proxyReqWs', proxyReq, req, socket, options, head);\n    }\n\n    // Error Handler\n    proxyReq.on('error', onOutgoingError);\n    proxyReq.on('response', function (res) {\n      // if upgrade event isn't going to happen, close the socket\n      if (!res.upgrade) {\n        socket.write(createHttpHeader('HTTP/' + res.httpVersion + ' ' + res.statusCode + ' ' + res.statusMessage, res.headers));\n        res.pipe(socket);\n      }\n    });\n    proxyReq.on('upgrade', function (proxyRes, proxySocket, proxyHead) {\n      proxySocket.on('error', onOutgoingError);\n\n      // Allow us to listen when the websocket has completed\n      proxySocket.on('end', function () {\n        server.emit('close', proxyRes, proxySocket, proxyHead);\n      });\n\n      // The pipe below will end proxySocket if socket closes cleanly, but not\n      // if it errors (eg, vanishes from the net and starts returning\n      // EHOSTUNREACH). We need to do that explicitly.\n      socket.on('error', function () {\n        proxySocket.end();\n      });\n      common.setupSocket(proxySocket);\n      if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead);\n\n      //\n      // Remark: Handle writing the headers to the socket when switching protocols\n      // Also handles when a header is an array\n      //\n      socket.write(createHttpHeader('HTTP/1.1 101 Switching Protocols', proxyRes.headers));\n      proxySocket.pipe(socket).pipe(proxySocket);\n      server.emit('open', proxySocket);\n      server.emit('proxySocket', proxySocket); //DEPRECATED.\n    });\n\n    return proxyReq.end(); // XXX: CHECK IF THIS IS THIS CORRECT\n\n    function onOutgoingError(err) {\n      if (clb) {\n        clb(err, req, socket);\n      } else {\n        server.emit('error', err, req, socket);\n      }\n      socket.end();\n    }\n  }\n};","map":{"version":3,"names":["http","require","https","common","module","exports","checkMethodAndHeader","req","socket","method","headers","upgrade","destroy","toLowerCase","XHeaders","options","xfwd","values","for","connection","remoteAddress","port","getPort","proto","hasEncryptedConnection","forEach","header","stream","head","server","clb","createHttpHeader","line","Object","keys","reduce","key","value","Array","isArray","push","i","length","join","setupSocket","unshift","proxyReq","isSSL","test","target","protocol","request","setupOutgoing","ssl","emit","on","onOutgoingError","res","write","httpVersion","statusCode","statusMessage","pipe","proxyRes","proxySocket","proxyHead","end","err"],"sources":["D:/Documents/VS Code Projects/c2hd/c2hd/node_modules/http-proxy/lib/http-proxy/passes/ws-incoming.js"],"sourcesContent":["var http   = require('http'),\r\n    https  = require('https'),\r\n    common = require('../common');\r\n\r\n/*!\r\n * Array of passes.\r\n *\r\n * A `pass` is just a function that is executed on `req, socket, options`\r\n * so that you can easily add new checks while still keeping the base\r\n * flexible.\r\n */\r\n\r\n/*\r\n * Websockets Passes\r\n *\r\n */\r\n\r\n\r\nmodule.exports = {\r\n  /**\r\n   * WebSocket requests must have the `GET` method and\r\n   * the `upgrade:websocket` header\r\n   *\r\n   * @param {ClientRequest} Req Request object\r\n   * @param {Socket} Websocket\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  checkMethodAndHeader : function checkMethodAndHeader(req, socket) {\r\n    if (req.method !== 'GET' || !req.headers.upgrade) {\r\n      socket.destroy();\r\n      return true;\r\n    }\r\n\r\n    if (req.headers.upgrade.toLowerCase() !== 'websocket') {\r\n      socket.destroy();\r\n      return true;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Sets `x-forwarded-*` headers if specified in config.\r\n   *\r\n   * @param {ClientRequest} Req Request object\r\n   * @param {Socket} Websocket\r\n   * @param {Object} Options Config object passed to the proxy\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  XHeaders : function XHeaders(req, socket, options) {\r\n    if(!options.xfwd) return;\r\n\r\n    var values = {\r\n      for  : req.connection.remoteAddress || req.socket.remoteAddress,\r\n      port : common.getPort(req),\r\n      proto: common.hasEncryptedConnection(req) ? 'wss' : 'ws'\r\n    };\r\n\r\n    ['for', 'port', 'proto'].forEach(function(header) {\r\n      req.headers['x-forwarded-' + header] =\r\n        (req.headers['x-forwarded-' + header] || '') +\r\n        (req.headers['x-forwarded-' + header] ? ',' : '') +\r\n        values[header];\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Does the actual proxying. Make the request and upgrade it\r\n   * send the Switching Protocols request and pipe the sockets.\r\n   *\r\n   * @param {ClientRequest} Req Request object\r\n   * @param {Socket} Websocket\r\n   * @param {Object} Options Config object passed to the proxy\r\n   *\r\n   * @api private\r\n   */\r\n  stream : function stream(req, socket, options, head, server, clb) {\r\n\r\n    var createHttpHeader = function(line, headers) {\r\n      return Object.keys(headers).reduce(function (head, key) {\r\n        var value = headers[key];\r\n\r\n        if (!Array.isArray(value)) {\r\n          head.push(key + ': ' + value);\r\n          return head;\r\n        }\r\n\r\n        for (var i = 0; i < value.length; i++) {\r\n          head.push(key + ': ' + value[i]);\r\n        }\r\n        return head;\r\n      }, [line])\r\n      .join('\\r\\n') + '\\r\\n\\r\\n';\r\n    }\r\n\r\n    common.setupSocket(socket);\r\n\r\n    if (head && head.length) socket.unshift(head);\r\n\r\n\r\n    var proxyReq = (common.isSSL.test(options.target.protocol) ? https : http).request(\r\n      common.setupOutgoing(options.ssl || {}, options, req)\r\n    );\r\n\r\n    // Enable developers to modify the proxyReq before headers are sent\r\n    if (server) { server.emit('proxyReqWs', proxyReq, req, socket, options, head); }\r\n\r\n    // Error Handler\r\n    proxyReq.on('error', onOutgoingError);\r\n    proxyReq.on('response', function (res) {\r\n      // if upgrade event isn't going to happen, close the socket\r\n      if (!res.upgrade) {\r\n        socket.write(createHttpHeader('HTTP/' + res.httpVersion + ' ' + res.statusCode + ' ' + res.statusMessage, res.headers));\r\n        res.pipe(socket);\r\n      }\r\n    });\r\n\r\n    proxyReq.on('upgrade', function(proxyRes, proxySocket, proxyHead) {\r\n      proxySocket.on('error', onOutgoingError);\r\n\r\n      // Allow us to listen when the websocket has completed\r\n      proxySocket.on('end', function () {\r\n        server.emit('close', proxyRes, proxySocket, proxyHead);\r\n      });\r\n\r\n      // The pipe below will end proxySocket if socket closes cleanly, but not\r\n      // if it errors (eg, vanishes from the net and starts returning\r\n      // EHOSTUNREACH). We need to do that explicitly.\r\n      socket.on('error', function () {\r\n        proxySocket.end();\r\n      });\r\n\r\n      common.setupSocket(proxySocket);\r\n\r\n      if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead);\r\n\r\n      //\r\n      // Remark: Handle writing the headers to the socket when switching protocols\r\n      // Also handles when a header is an array\r\n      //\r\n      socket.write(createHttpHeader('HTTP/1.1 101 Switching Protocols', proxyRes.headers));\r\n\r\n      proxySocket.pipe(socket).pipe(proxySocket);\r\n\r\n      server.emit('open', proxySocket);\r\n      server.emit('proxySocket', proxySocket);  //DEPRECATED.\r\n    });\r\n\r\n    return proxyReq.end(); // XXX: CHECK IF THIS IS THIS CORRECT\r\n\r\n    function onOutgoingError(err) {\r\n      if (clb) {\r\n        clb(err, req, socket);\r\n      } else {\r\n        server.emit('error', err, req, socket);\r\n      }\r\n      socket.end();\r\n    }\r\n  }\r\n};\r\n"],"mappings":"AAAA,IAAIA,IAAI,GAAKC,OAAO,CAAC,MAAM,CAAC;EACxBC,KAAK,GAAID,OAAO,CAAC,OAAO,CAAC;EACzBE,MAAM,GAAGF,OAAO,CAAC,WAAW,CAAC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAGAG,MAAM,CAACC,OAAO,GAAG;EACf;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEEC,oBAAoB,EAAG,SAASA,oBAAoB,CAACC,GAAG,EAAEC,MAAM,EAAE;IAChE,IAAID,GAAG,CAACE,MAAM,KAAK,KAAK,IAAI,CAACF,GAAG,CAACG,OAAO,CAACC,OAAO,EAAE;MAChDH,MAAM,CAACI,OAAO,EAAE;MAChB,OAAO,IAAI;IACb;IAEA,IAAIL,GAAG,CAACG,OAAO,CAACC,OAAO,CAACE,WAAW,EAAE,KAAK,WAAW,EAAE;MACrDL,MAAM,CAACI,OAAO,EAAE;MAChB,OAAO,IAAI;IACb;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEEE,QAAQ,EAAG,SAASA,QAAQ,CAACP,GAAG,EAAEC,MAAM,EAAEO,OAAO,EAAE;IACjD,IAAG,CAACA,OAAO,CAACC,IAAI,EAAE;IAElB,IAAIC,MAAM,GAAG;MACXC,GAAG,EAAIX,GAAG,CAACY,UAAU,CAACC,aAAa,IAAIb,GAAG,CAACC,MAAM,CAACY,aAAa;MAC/DC,IAAI,EAAGlB,MAAM,CAACmB,OAAO,CAACf,GAAG,CAAC;MAC1BgB,KAAK,EAAEpB,MAAM,CAACqB,sBAAsB,CAACjB,GAAG,CAAC,GAAG,KAAK,GAAG;IACtD,CAAC;IAED,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,CAAC,CAACkB,OAAO,CAAC,UAASC,MAAM,EAAE;MAChDnB,GAAG,CAACG,OAAO,CAAC,cAAc,GAAGgB,MAAM,CAAC,GAClC,CAACnB,GAAG,CAACG,OAAO,CAAC,cAAc,GAAGgB,MAAM,CAAC,IAAI,EAAE,KAC1CnB,GAAG,CAACG,OAAO,CAAC,cAAc,GAAGgB,MAAM,CAAC,GAAG,GAAG,GAAG,EAAE,CAAC,GACjDT,MAAM,CAACS,MAAM,CAAC;IAClB,CAAC,CAAC;EACJ,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,MAAM,EAAG,SAASA,MAAM,CAACpB,GAAG,EAAEC,MAAM,EAAEO,OAAO,EAAEa,IAAI,EAAEC,MAAM,EAAEC,GAAG,EAAE;IAEhE,IAAIC,gBAAgB,GAAG,UAASC,IAAI,EAAEtB,OAAO,EAAE;MAC7C,OAAOuB,MAAM,CAACC,IAAI,CAACxB,OAAO,CAAC,CAACyB,MAAM,CAAC,UAAUP,IAAI,EAAEQ,GAAG,EAAE;QACtD,IAAIC,KAAK,GAAG3B,OAAO,CAAC0B,GAAG,CAAC;QAExB,IAAI,CAACE,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;UACzBT,IAAI,CAACY,IAAI,CAACJ,GAAG,GAAG,IAAI,GAAGC,KAAK,CAAC;UAC7B,OAAOT,IAAI;QACb;QAEA,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,CAACK,MAAM,EAAED,CAAC,EAAE,EAAE;UACrCb,IAAI,CAACY,IAAI,CAACJ,GAAG,GAAG,IAAI,GAAGC,KAAK,CAACI,CAAC,CAAC,CAAC;QAClC;QACA,OAAOb,IAAI;MACb,CAAC,EAAE,CAACI,IAAI,CAAC,CAAC,CACTW,IAAI,CAAC,MAAM,CAAC,GAAG,UAAU;IAC5B,CAAC;IAEDxC,MAAM,CAACyC,WAAW,CAACpC,MAAM,CAAC;IAE1B,IAAIoB,IAAI,IAAIA,IAAI,CAACc,MAAM,EAAElC,MAAM,CAACqC,OAAO,CAACjB,IAAI,CAAC;IAG7C,IAAIkB,QAAQ,GAAG,CAAC3C,MAAM,CAAC4C,KAAK,CAACC,IAAI,CAACjC,OAAO,CAACkC,MAAM,CAACC,QAAQ,CAAC,GAAGhD,KAAK,GAAGF,IAAI,EAAEmD,OAAO,CAChFhD,MAAM,CAACiD,aAAa,CAACrC,OAAO,CAACsC,GAAG,IAAI,CAAC,CAAC,EAAEtC,OAAO,EAAER,GAAG,CAAC,CACtD;;IAED;IACA,IAAIsB,MAAM,EAAE;MAAEA,MAAM,CAACyB,IAAI,CAAC,YAAY,EAAER,QAAQ,EAAEvC,GAAG,EAAEC,MAAM,EAAEO,OAAO,EAAEa,IAAI,CAAC;IAAE;;IAE/E;IACAkB,QAAQ,CAACS,EAAE,CAAC,OAAO,EAAEC,eAAe,CAAC;IACrCV,QAAQ,CAACS,EAAE,CAAC,UAAU,EAAE,UAAUE,GAAG,EAAE;MACrC;MACA,IAAI,CAACA,GAAG,CAAC9C,OAAO,EAAE;QAChBH,MAAM,CAACkD,KAAK,CAAC3B,gBAAgB,CAAC,OAAO,GAAG0B,GAAG,CAACE,WAAW,GAAG,GAAG,GAAGF,GAAG,CAACG,UAAU,GAAG,GAAG,GAAGH,GAAG,CAACI,aAAa,EAAEJ,GAAG,CAAC/C,OAAO,CAAC,CAAC;QACvH+C,GAAG,CAACK,IAAI,CAACtD,MAAM,CAAC;MAClB;IACF,CAAC,CAAC;IAEFsC,QAAQ,CAACS,EAAE,CAAC,SAAS,EAAE,UAASQ,QAAQ,EAAEC,WAAW,EAAEC,SAAS,EAAE;MAChED,WAAW,CAACT,EAAE,CAAC,OAAO,EAAEC,eAAe,CAAC;;MAExC;MACAQ,WAAW,CAACT,EAAE,CAAC,KAAK,EAAE,YAAY;QAChC1B,MAAM,CAACyB,IAAI,CAAC,OAAO,EAAES,QAAQ,EAAEC,WAAW,EAAEC,SAAS,CAAC;MACxD,CAAC,CAAC;;MAEF;MACA;MACA;MACAzD,MAAM,CAAC+C,EAAE,CAAC,OAAO,EAAE,YAAY;QAC7BS,WAAW,CAACE,GAAG,EAAE;MACnB,CAAC,CAAC;MAEF/D,MAAM,CAACyC,WAAW,CAACoB,WAAW,CAAC;MAE/B,IAAIC,SAAS,IAAIA,SAAS,CAACvB,MAAM,EAAEsB,WAAW,CAACnB,OAAO,CAACoB,SAAS,CAAC;;MAEjE;MACA;MACA;MACA;MACAzD,MAAM,CAACkD,KAAK,CAAC3B,gBAAgB,CAAC,kCAAkC,EAAEgC,QAAQ,CAACrD,OAAO,CAAC,CAAC;MAEpFsD,WAAW,CAACF,IAAI,CAACtD,MAAM,CAAC,CAACsD,IAAI,CAACE,WAAW,CAAC;MAE1CnC,MAAM,CAACyB,IAAI,CAAC,MAAM,EAAEU,WAAW,CAAC;MAChCnC,MAAM,CAACyB,IAAI,CAAC,aAAa,EAAEU,WAAW,CAAC,CAAC,CAAE;IAC5C,CAAC,CAAC;;IAEF,OAAOlB,QAAQ,CAACoB,GAAG,EAAE,CAAC,CAAC;;IAEvB,SAASV,eAAe,CAACW,GAAG,EAAE;MAC5B,IAAIrC,GAAG,EAAE;QACPA,GAAG,CAACqC,GAAG,EAAE5D,GAAG,EAAEC,MAAM,CAAC;MACvB,CAAC,MAAM;QACLqB,MAAM,CAACyB,IAAI,CAAC,OAAO,EAAEa,GAAG,EAAE5D,GAAG,EAAEC,MAAM,CAAC;MACxC;MACAA,MAAM,CAAC0D,GAAG,EAAE;IACd;EACF;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}