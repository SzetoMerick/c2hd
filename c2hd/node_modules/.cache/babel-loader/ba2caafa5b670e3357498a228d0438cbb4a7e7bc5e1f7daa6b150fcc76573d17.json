{"ast":null,"code":"/*!\r\n * on-finished\r\n * Copyright(c) 2013 Jonathan Ong\r\n * Copyright(c) 2014 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n\n'use strict';\n\n/**\r\n * Module exports.\r\n * @public\r\n */\nmodule.exports = onFinished;\nmodule.exports.isFinished = isFinished;\n\n/**\r\n * Module dependencies.\r\n * @private\r\n */\n\nvar asyncHooks = tryRequireAsyncHooks();\nvar first = require('ee-first');\n\n/**\r\n * Variables.\r\n * @private\r\n */\n\n/* istanbul ignore next */\nvar defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {\n  process.nextTick(fn.bind.apply(fn, arguments));\n};\n\n/**\r\n * Invoke callback when the response has finished, useful for\r\n * cleaning up resources afterwards.\r\n *\r\n * @param {object} msg\r\n * @param {function} listener\r\n * @return {object}\r\n * @public\r\n */\n\nfunction onFinished(msg, listener) {\n  if (isFinished(msg) !== false) {\n    defer(listener, null, msg);\n    return msg;\n  }\n\n  // attach the listener to the message\n  attachListener(msg, wrap(listener));\n  return msg;\n}\n\n/**\r\n * Determine if message is already finished.\r\n *\r\n * @param {object} msg\r\n * @return {boolean}\r\n * @public\r\n */\n\nfunction isFinished(msg) {\n  var socket = msg.socket;\n  if (typeof msg.finished === 'boolean') {\n    // OutgoingMessage\n    return Boolean(msg.finished || socket && !socket.writable);\n  }\n  if (typeof msg.complete === 'boolean') {\n    // IncomingMessage\n    return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);\n  }\n\n  // don't know\n  return undefined;\n}\n\n/**\r\n * Attach a finished listener to the message.\r\n *\r\n * @param {object} msg\r\n * @param {function} callback\r\n * @private\r\n */\n\nfunction attachFinishedListener(msg, callback) {\n  var eeMsg;\n  var eeSocket;\n  var finished = false;\n  function onFinish(error) {\n    eeMsg.cancel();\n    eeSocket.cancel();\n    finished = true;\n    callback(error);\n  }\n\n  // finished on first message event\n  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish);\n  function onSocket(socket) {\n    // remove listener\n    msg.removeListener('socket', onSocket);\n    if (finished) return;\n    if (eeMsg !== eeSocket) return;\n\n    // finished on first socket event\n    eeSocket = first([[socket, 'error', 'close']], onFinish);\n  }\n  if (msg.socket) {\n    // socket already assigned\n    onSocket(msg.socket);\n    return;\n  }\n\n  // wait for socket to be assigned\n  msg.on('socket', onSocket);\n  if (msg.socket === undefined) {\n    // istanbul ignore next: node.js 0.8 patch\n    patchAssignSocket(msg, onSocket);\n  }\n}\n\n/**\r\n * Attach the listener to the message.\r\n *\r\n * @param {object} msg\r\n * @return {function}\r\n * @private\r\n */\n\nfunction attachListener(msg, listener) {\n  var attached = msg.__onFinished;\n\n  // create a private single listener with queue\n  if (!attached || !attached.queue) {\n    attached = msg.__onFinished = createListener(msg);\n    attachFinishedListener(msg, attached);\n  }\n  attached.queue.push(listener);\n}\n\n/**\r\n * Create listener on message.\r\n *\r\n * @param {object} msg\r\n * @return {function}\r\n * @private\r\n */\n\nfunction createListener(msg) {\n  function listener(err) {\n    if (msg.__onFinished === listener) msg.__onFinished = null;\n    if (!listener.queue) return;\n    var queue = listener.queue;\n    listener.queue = null;\n    for (var i = 0; i < queue.length; i++) {\n      queue[i](err, msg);\n    }\n  }\n  listener.queue = [];\n  return listener;\n}\n\n/**\r\n * Patch ServerResponse.prototype.assignSocket for node.js 0.8.\r\n *\r\n * @param {ServerResponse} res\r\n * @param {function} callback\r\n * @private\r\n */\n\n// istanbul ignore next: node.js 0.8 patch\nfunction patchAssignSocket(res, callback) {\n  var assignSocket = res.assignSocket;\n  if (typeof assignSocket !== 'function') return;\n\n  // res.on('socket', callback) is broken in 0.8\n  res.assignSocket = function _assignSocket(socket) {\n    assignSocket.call(this, socket);\n    callback(socket);\n  };\n}\n\n/**\r\n * Try to require async_hooks\r\n * @private\r\n */\n\nfunction tryRequireAsyncHooks() {\n  try {\n    return require('async_hooks');\n  } catch (e) {\n    return {};\n  }\n}\n\n/**\r\n * Wrap function with async resource, if possible.\r\n * AsyncResource.bind static method backported.\r\n * @private\r\n */\n\nfunction wrap(fn) {\n  var res;\n\n  // create anonymous resource\n  if (asyncHooks.AsyncResource) {\n    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');\n  }\n\n  // incompatible node.js\n  if (!res || !res.runInAsyncScope) {\n    return fn;\n  }\n\n  // return bound function\n  return res.runInAsyncScope.bind(res, fn, null);\n}","map":{"version":3,"names":["module","exports","onFinished","isFinished","asyncHooks","tryRequireAsyncHooks","first","require","defer","setImmediate","fn","process","nextTick","bind","apply","arguments","msg","listener","attachListener","wrap","socket","finished","Boolean","writable","complete","upgrade","readable","undefined","attachFinishedListener","callback","eeMsg","eeSocket","onFinish","error","cancel","onSocket","removeListener","on","patchAssignSocket","attached","__onFinished","queue","createListener","push","err","i","length","res","assignSocket","_assignSocket","call","e","AsyncResource","name","runInAsyncScope"],"sources":["D:/Documents/VS Code Projects/c2hd/c2hd/node_modules/on-finished/index.js"],"sourcesContent":["/*!\r\n * on-finished\r\n * Copyright(c) 2013 Jonathan Ong\r\n * Copyright(c) 2014 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\n'use strict'\r\n\r\n/**\r\n * Module exports.\r\n * @public\r\n */\r\n\r\nmodule.exports = onFinished\r\nmodule.exports.isFinished = isFinished\r\n\r\n/**\r\n * Module dependencies.\r\n * @private\r\n */\r\n\r\nvar asyncHooks = tryRequireAsyncHooks()\r\nvar first = require('ee-first')\r\n\r\n/**\r\n * Variables.\r\n * @private\r\n */\r\n\r\n/* istanbul ignore next */\r\nvar defer = typeof setImmediate === 'function'\r\n  ? setImmediate\r\n  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)) }\r\n\r\n/**\r\n * Invoke callback when the response has finished, useful for\r\n * cleaning up resources afterwards.\r\n *\r\n * @param {object} msg\r\n * @param {function} listener\r\n * @return {object}\r\n * @public\r\n */\r\n\r\nfunction onFinished (msg, listener) {\r\n  if (isFinished(msg) !== false) {\r\n    defer(listener, null, msg)\r\n    return msg\r\n  }\r\n\r\n  // attach the listener to the message\r\n  attachListener(msg, wrap(listener))\r\n\r\n  return msg\r\n}\r\n\r\n/**\r\n * Determine if message is already finished.\r\n *\r\n * @param {object} msg\r\n * @return {boolean}\r\n * @public\r\n */\r\n\r\nfunction isFinished (msg) {\r\n  var socket = msg.socket\r\n\r\n  if (typeof msg.finished === 'boolean') {\r\n    // OutgoingMessage\r\n    return Boolean(msg.finished || (socket && !socket.writable))\r\n  }\r\n\r\n  if (typeof msg.complete === 'boolean') {\r\n    // IncomingMessage\r\n    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))\r\n  }\r\n\r\n  // don't know\r\n  return undefined\r\n}\r\n\r\n/**\r\n * Attach a finished listener to the message.\r\n *\r\n * @param {object} msg\r\n * @param {function} callback\r\n * @private\r\n */\r\n\r\nfunction attachFinishedListener (msg, callback) {\r\n  var eeMsg\r\n  var eeSocket\r\n  var finished = false\r\n\r\n  function onFinish (error) {\r\n    eeMsg.cancel()\r\n    eeSocket.cancel()\r\n\r\n    finished = true\r\n    callback(error)\r\n  }\r\n\r\n  // finished on first message event\r\n  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)\r\n\r\n  function onSocket (socket) {\r\n    // remove listener\r\n    msg.removeListener('socket', onSocket)\r\n\r\n    if (finished) return\r\n    if (eeMsg !== eeSocket) return\r\n\r\n    // finished on first socket event\r\n    eeSocket = first([[socket, 'error', 'close']], onFinish)\r\n  }\r\n\r\n  if (msg.socket) {\r\n    // socket already assigned\r\n    onSocket(msg.socket)\r\n    return\r\n  }\r\n\r\n  // wait for socket to be assigned\r\n  msg.on('socket', onSocket)\r\n\r\n  if (msg.socket === undefined) {\r\n    // istanbul ignore next: node.js 0.8 patch\r\n    patchAssignSocket(msg, onSocket)\r\n  }\r\n}\r\n\r\n/**\r\n * Attach the listener to the message.\r\n *\r\n * @param {object} msg\r\n * @return {function}\r\n * @private\r\n */\r\n\r\nfunction attachListener (msg, listener) {\r\n  var attached = msg.__onFinished\r\n\r\n  // create a private single listener with queue\r\n  if (!attached || !attached.queue) {\r\n    attached = msg.__onFinished = createListener(msg)\r\n    attachFinishedListener(msg, attached)\r\n  }\r\n\r\n  attached.queue.push(listener)\r\n}\r\n\r\n/**\r\n * Create listener on message.\r\n *\r\n * @param {object} msg\r\n * @return {function}\r\n * @private\r\n */\r\n\r\nfunction createListener (msg) {\r\n  function listener (err) {\r\n    if (msg.__onFinished === listener) msg.__onFinished = null\r\n    if (!listener.queue) return\r\n\r\n    var queue = listener.queue\r\n    listener.queue = null\r\n\r\n    for (var i = 0; i < queue.length; i++) {\r\n      queue[i](err, msg)\r\n    }\r\n  }\r\n\r\n  listener.queue = []\r\n\r\n  return listener\r\n}\r\n\r\n/**\r\n * Patch ServerResponse.prototype.assignSocket for node.js 0.8.\r\n *\r\n * @param {ServerResponse} res\r\n * @param {function} callback\r\n * @private\r\n */\r\n\r\n// istanbul ignore next: node.js 0.8 patch\r\nfunction patchAssignSocket (res, callback) {\r\n  var assignSocket = res.assignSocket\r\n\r\n  if (typeof assignSocket !== 'function') return\r\n\r\n  // res.on('socket', callback) is broken in 0.8\r\n  res.assignSocket = function _assignSocket (socket) {\r\n    assignSocket.call(this, socket)\r\n    callback(socket)\r\n  }\r\n}\r\n\r\n/**\r\n * Try to require async_hooks\r\n * @private\r\n */\r\n\r\nfunction tryRequireAsyncHooks () {\r\n  try {\r\n    return require('async_hooks')\r\n  } catch (e) {\r\n    return {}\r\n  }\r\n}\r\n\r\n/**\r\n * Wrap function with async resource, if possible.\r\n * AsyncResource.bind static method backported.\r\n * @private\r\n */\r\n\r\nfunction wrap (fn) {\r\n  var res\r\n\r\n  // create anonymous resource\r\n  if (asyncHooks.AsyncResource) {\r\n    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn')\r\n  }\r\n\r\n  // incompatible node.js\r\n  if (!res || !res.runInAsyncScope) {\r\n    return fn\r\n  }\r\n\r\n  // return bound function\r\n  return res.runInAsyncScope.bind(res, fn, null)\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}