{"ast":null,"code":"/*!\r\n * body-parser\r\n * Copyright(c) 2014 Jonathan Ong\r\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n\n'use strict';\n\n/**\r\n * Module dependencies.\r\n * @private\r\n */\nvar bytes = require('bytes');\nvar contentType = require('content-type');\nvar createError = require('http-errors');\nvar debug = require('debug')('body-parser:urlencoded');\nvar deprecate = require('depd')('body-parser');\nvar read = require('../read');\nvar typeis = require('type-is');\n\n/**\r\n * Module exports.\r\n */\n\nmodule.exports = urlencoded;\n\n/**\r\n * Cache of parser modules.\r\n */\n\nvar parsers = Object.create(null);\n\n/**\r\n * Create a middleware to parse urlencoded bodies.\r\n *\r\n * @param {object} [options]\r\n * @return {function}\r\n * @public\r\n */\n\nfunction urlencoded(options) {\n  var opts = options || {};\n\n  // notice because option default will flip in next major\n  if (opts.extended === undefined) {\n    deprecate('undefined extended: provide extended option');\n  }\n  var extended = opts.extended !== false;\n  var inflate = opts.inflate !== false;\n  var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;\n  var type = opts.type || 'application/x-www-form-urlencoded';\n  var verify = opts.verify || false;\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function');\n  }\n\n  // create the appropriate query parser\n  var queryparse = extended ? extendedparser(opts) : simpleparser(opts);\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;\n  function parse(body) {\n    return body.length ? queryparse(body) : {};\n  }\n  return function urlencodedParser(req, res, next) {\n    if (req._body) {\n      debug('body already parsed');\n      next();\n      return;\n    }\n    req.body = req.body || {};\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body');\n      next();\n      return;\n    }\n    debug('content-type %j', req.headers['content-type']);\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing');\n      next();\n      return;\n    }\n\n    // assert charset\n    var charset = getCharset(req) || 'utf-8';\n    if (charset !== 'utf-8') {\n      debug('invalid charset');\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }));\n      return;\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      debug: debug,\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    });\n  };\n}\n\n/**\r\n * Get the extended query parser.\r\n *\r\n * @param {object} options\r\n */\n\nfunction extendedparser(options) {\n  var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;\n  var parse = parser('qs');\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number');\n  }\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0;\n  }\n  return function queryparse(body) {\n    var paramCount = parameterCount(body, parameterLimit);\n    if (paramCount === undefined) {\n      debug('too many parameters');\n      throw createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      });\n    }\n    var arrayLimit = Math.max(100, paramCount);\n    debug('parse extended urlencoding');\n    return parse(body, {\n      allowPrototypes: true,\n      arrayLimit: arrayLimit,\n      depth: Infinity,\n      parameterLimit: parameterLimit\n    });\n  };\n}\n\n/**\r\n * Get the charset of a request.\r\n *\r\n * @param {object} req\r\n * @api private\r\n */\n\nfunction getCharset(req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase();\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\r\n * Count the number of parameters, stopping once limit reached\r\n *\r\n * @param {string} body\r\n * @param {number} limit\r\n * @api private\r\n */\n\nfunction parameterCount(body, limit) {\n  var count = 0;\n  var index = 0;\n  while ((index = body.indexOf('&', index)) !== -1) {\n    count++;\n    index++;\n    if (count === limit) {\n      return undefined;\n    }\n  }\n  return count;\n}\n\n/**\r\n * Get parser for module name dynamically.\r\n *\r\n * @param {string} name\r\n * @return {function}\r\n * @api private\r\n */\n\nfunction parser(name) {\n  var mod = parsers[name];\n  if (mod !== undefined) {\n    return mod.parse;\n  }\n\n  // this uses a switch for static require analysis\n  switch (name) {\n    case 'qs':\n      mod = require('qs');\n      break;\n    case 'querystring':\n      mod = require('querystring');\n      break;\n  }\n\n  // store to prevent invoking require()\n  parsers[name] = mod;\n  return mod.parse;\n}\n\n/**\r\n * Get the simple query parser.\r\n *\r\n * @param {object} options\r\n */\n\nfunction simpleparser(options) {\n  var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;\n  var parse = parser('querystring');\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number');\n  }\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0;\n  }\n  return function queryparse(body) {\n    var paramCount = parameterCount(body, parameterLimit);\n    if (paramCount === undefined) {\n      debug('too many parameters');\n      throw createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      });\n    }\n    debug('parse urlencoding');\n    return parse(body, undefined, undefined, {\n      maxKeys: parameterLimit\n    });\n  };\n}\n\n/**\r\n * Get the simple type checker.\r\n *\r\n * @param {string} type\r\n * @return {function}\r\n */\n\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type));\n  };\n}","map":{"version":3,"names":["bytes","require","contentType","createError","debug","deprecate","read","typeis","module","exports","urlencoded","parsers","Object","create","options","opts","extended","undefined","inflate","limit","parse","type","verify","TypeError","queryparse","extendedparser","simpleparser","shouldParse","typeChecker","body","length","urlencodedParser","req","res","next","_body","hasBody","headers","charset","getCharset","toUpperCase","encoding","parameterLimit","parser","isNaN","isFinite","paramCount","parameterCount","arrayLimit","Math","max","allowPrototypes","depth","Infinity","parameters","toLowerCase","e","count","index","indexOf","name","mod","maxKeys","checkType","Boolean"],"sources":["D:/Documents/VS Code Projects/c2hd/c2hd/node_modules/body-parser/lib/types/urlencoded.js"],"sourcesContent":["/*!\r\n * body-parser\r\n * Copyright(c) 2014 Jonathan Ong\r\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\n'use strict'\r\n\r\n/**\r\n * Module dependencies.\r\n * @private\r\n */\r\n\r\nvar bytes = require('bytes')\r\nvar contentType = require('content-type')\r\nvar createError = require('http-errors')\r\nvar debug = require('debug')('body-parser:urlencoded')\r\nvar deprecate = require('depd')('body-parser')\r\nvar read = require('../read')\r\nvar typeis = require('type-is')\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = urlencoded\r\n\r\n/**\r\n * Cache of parser modules.\r\n */\r\n\r\nvar parsers = Object.create(null)\r\n\r\n/**\r\n * Create a middleware to parse urlencoded bodies.\r\n *\r\n * @param {object} [options]\r\n * @return {function}\r\n * @public\r\n */\r\n\r\nfunction urlencoded (options) {\r\n  var opts = options || {}\r\n\r\n  // notice because option default will flip in next major\r\n  if (opts.extended === undefined) {\r\n    deprecate('undefined extended: provide extended option')\r\n  }\r\n\r\n  var extended = opts.extended !== false\r\n  var inflate = opts.inflate !== false\r\n  var limit = typeof opts.limit !== 'number'\r\n    ? bytes.parse(opts.limit || '100kb')\r\n    : opts.limit\r\n  var type = opts.type || 'application/x-www-form-urlencoded'\r\n  var verify = opts.verify || false\r\n\r\n  if (verify !== false && typeof verify !== 'function') {\r\n    throw new TypeError('option verify must be function')\r\n  }\r\n\r\n  // create the appropriate query parser\r\n  var queryparse = extended\r\n    ? extendedparser(opts)\r\n    : simpleparser(opts)\r\n\r\n  // create the appropriate type checking function\r\n  var shouldParse = typeof type !== 'function'\r\n    ? typeChecker(type)\r\n    : type\r\n\r\n  function parse (body) {\r\n    return body.length\r\n      ? queryparse(body)\r\n      : {}\r\n  }\r\n\r\n  return function urlencodedParser (req, res, next) {\r\n    if (req._body) {\r\n      debug('body already parsed')\r\n      next()\r\n      return\r\n    }\r\n\r\n    req.body = req.body || {}\r\n\r\n    // skip requests without bodies\r\n    if (!typeis.hasBody(req)) {\r\n      debug('skip empty body')\r\n      next()\r\n      return\r\n    }\r\n\r\n    debug('content-type %j', req.headers['content-type'])\r\n\r\n    // determine if request should be parsed\r\n    if (!shouldParse(req)) {\r\n      debug('skip parsing')\r\n      next()\r\n      return\r\n    }\r\n\r\n    // assert charset\r\n    var charset = getCharset(req) || 'utf-8'\r\n    if (charset !== 'utf-8') {\r\n      debug('invalid charset')\r\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\r\n        charset: charset,\r\n        type: 'charset.unsupported'\r\n      }))\r\n      return\r\n    }\r\n\r\n    // read\r\n    read(req, res, next, parse, debug, {\r\n      debug: debug,\r\n      encoding: charset,\r\n      inflate: inflate,\r\n      limit: limit,\r\n      verify: verify\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * Get the extended query parser.\r\n *\r\n * @param {object} options\r\n */\r\n\r\nfunction extendedparser (options) {\r\n  var parameterLimit = options.parameterLimit !== undefined\r\n    ? options.parameterLimit\r\n    : 1000\r\n  var parse = parser('qs')\r\n\r\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\r\n    throw new TypeError('option parameterLimit must be a positive number')\r\n  }\r\n\r\n  if (isFinite(parameterLimit)) {\r\n    parameterLimit = parameterLimit | 0\r\n  }\r\n\r\n  return function queryparse (body) {\r\n    var paramCount = parameterCount(body, parameterLimit)\r\n\r\n    if (paramCount === undefined) {\r\n      debug('too many parameters')\r\n      throw createError(413, 'too many parameters', {\r\n        type: 'parameters.too.many'\r\n      })\r\n    }\r\n\r\n    var arrayLimit = Math.max(100, paramCount)\r\n\r\n    debug('parse extended urlencoding')\r\n    return parse(body, {\r\n      allowPrototypes: true,\r\n      arrayLimit: arrayLimit,\r\n      depth: Infinity,\r\n      parameterLimit: parameterLimit\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * Get the charset of a request.\r\n *\r\n * @param {object} req\r\n * @api private\r\n */\r\n\r\nfunction getCharset (req) {\r\n  try {\r\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\r\n  } catch (e) {\r\n    return undefined\r\n  }\r\n}\r\n\r\n/**\r\n * Count the number of parameters, stopping once limit reached\r\n *\r\n * @param {string} body\r\n * @param {number} limit\r\n * @api private\r\n */\r\n\r\nfunction parameterCount (body, limit) {\r\n  var count = 0\r\n  var index = 0\r\n\r\n  while ((index = body.indexOf('&', index)) !== -1) {\r\n    count++\r\n    index++\r\n\r\n    if (count === limit) {\r\n      return undefined\r\n    }\r\n  }\r\n\r\n  return count\r\n}\r\n\r\n/**\r\n * Get parser for module name dynamically.\r\n *\r\n * @param {string} name\r\n * @return {function}\r\n * @api private\r\n */\r\n\r\nfunction parser (name) {\r\n  var mod = parsers[name]\r\n\r\n  if (mod !== undefined) {\r\n    return mod.parse\r\n  }\r\n\r\n  // this uses a switch for static require analysis\r\n  switch (name) {\r\n    case 'qs':\r\n      mod = require('qs')\r\n      break\r\n    case 'querystring':\r\n      mod = require('querystring')\r\n      break\r\n  }\r\n\r\n  // store to prevent invoking require()\r\n  parsers[name] = mod\r\n\r\n  return mod.parse\r\n}\r\n\r\n/**\r\n * Get the simple query parser.\r\n *\r\n * @param {object} options\r\n */\r\n\r\nfunction simpleparser (options) {\r\n  var parameterLimit = options.parameterLimit !== undefined\r\n    ? options.parameterLimit\r\n    : 1000\r\n  var parse = parser('querystring')\r\n\r\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\r\n    throw new TypeError('option parameterLimit must be a positive number')\r\n  }\r\n\r\n  if (isFinite(parameterLimit)) {\r\n    parameterLimit = parameterLimit | 0\r\n  }\r\n\r\n  return function queryparse (body) {\r\n    var paramCount = parameterCount(body, parameterLimit)\r\n\r\n    if (paramCount === undefined) {\r\n      debug('too many parameters')\r\n      throw createError(413, 'too many parameters', {\r\n        type: 'parameters.too.many'\r\n      })\r\n    }\r\n\r\n    debug('parse urlencoding')\r\n    return parse(body, undefined, undefined, { maxKeys: parameterLimit })\r\n  }\r\n}\r\n\r\n/**\r\n * Get the simple type checker.\r\n *\r\n * @param {string} type\r\n * @return {function}\r\n */\r\n\r\nfunction typeChecker (type) {\r\n  return function checkType (req) {\r\n    return Boolean(typeis(req, type))\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}