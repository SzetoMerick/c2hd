{"ast":null,"code":"'use strict';\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n  return false;\n};\n\n/**\r\n * Find a node of the given type\r\n */\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n/**\r\n * Find a node of the given type\r\n */\n\nexports.exceedsLimit = function (min, max) {\n  let step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let limit = arguments.length > 3 ? arguments[3] : undefined;\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return (Number(max) - Number(min)) / Number(step) >= limit;\n};\n\n/**\r\n * Escape the given node with '\\\\' before node.value\r\n */\n\nexports.escapeNode = function (block) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let type = arguments.length > 2 ? arguments[2] : undefined;\n  let node = block.nodes[n];\n  if (!node) return;\n  if (type && node.type === type || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n\n/**\r\n * Returns true if the given brace node should be enclosed in literal braces\r\n */\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n  if (node.commas >> 0 + node.ranges >> 0 === 0) {\n    node.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\r\n * Returns true if a brace node is invalid.\r\n */\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n  if (block.commas >> 0 + block.ranges >> 0 === 0) {\n    block.invalid = true;\n    return true;\n  }\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\r\n * Returns true if a node is an open or close node\r\n */\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n  return node.open === true || node.close === true;\n};\n\n/**\r\n * Reduce an array of text nodes.\r\n */\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n\n/**\r\n * Flatten an array\r\n */\n\nexports.flatten = function () {\n  const result = [];\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      let ele = arr[i];\n      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n    }\n    return result;\n  };\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  flat(args);\n  return result;\n};","map":{"version":3,"names":["exports","isInteger","num","Number","trim","find","node","type","nodes","exceedsLimit","min","max","step","limit","escapeNode","block","n","escaped","value","encloseBrace","commas","ranges","invalid","isInvalidBrace","dollar","open","close","isOpenOrClose","reduce","acc","push","flatten","result","flat","arr","i","length","ele","Array","isArray","args"],"sources":["D:/Documents/VS Code Projects/c2hd/c2hd/node_modules/braces/lib/utils.js"],"sourcesContent":["'use strict';\r\n\r\nexports.isInteger = num => {\r\n  if (typeof num === 'number') {\r\n    return Number.isInteger(num);\r\n  }\r\n  if (typeof num === 'string' && num.trim() !== '') {\r\n    return Number.isInteger(Number(num));\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Find a node of the given type\r\n */\r\n\r\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\r\n\r\n/**\r\n * Find a node of the given type\r\n */\r\n\r\nexports.exceedsLimit = (min, max, step = 1, limit) => {\r\n  if (limit === false) return false;\r\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\r\n  return ((Number(max) - Number(min)) / Number(step)) >= limit;\r\n};\r\n\r\n/**\r\n * Escape the given node with '\\\\' before node.value\r\n */\r\n\r\nexports.escapeNode = (block, n = 0, type) => {\r\n  let node = block.nodes[n];\r\n  if (!node) return;\r\n\r\n  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\r\n    if (node.escaped !== true) {\r\n      node.value = '\\\\' + node.value;\r\n      node.escaped = true;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Returns true if the given brace node should be enclosed in literal braces\r\n */\r\n\r\nexports.encloseBrace = node => {\r\n  if (node.type !== 'brace') return false;\r\n  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\r\n    node.invalid = true;\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Returns true if a brace node is invalid.\r\n */\r\n\r\nexports.isInvalidBrace = block => {\r\n  if (block.type !== 'brace') return false;\r\n  if (block.invalid === true || block.dollar) return true;\r\n  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\r\n    block.invalid = true;\r\n    return true;\r\n  }\r\n  if (block.open !== true || block.close !== true) {\r\n    block.invalid = true;\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Returns true if a node is an open or close node\r\n */\r\n\r\nexports.isOpenOrClose = node => {\r\n  if (node.type === 'open' || node.type === 'close') {\r\n    return true;\r\n  }\r\n  return node.open === true || node.close === true;\r\n};\r\n\r\n/**\r\n * Reduce an array of text nodes.\r\n */\r\n\r\nexports.reduce = nodes => nodes.reduce((acc, node) => {\r\n  if (node.type === 'text') acc.push(node.value);\r\n  if (node.type === 'range') node.type = 'text';\r\n  return acc;\r\n}, []);\r\n\r\n/**\r\n * Flatten an array\r\n */\r\n\r\nexports.flatten = (...args) => {\r\n  const result = [];\r\n  const flat = arr => {\r\n    for (let i = 0; i < arr.length; i++) {\r\n      let ele = arr[i];\r\n      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\r\n    }\r\n    return result;\r\n  };\r\n  flat(args);\r\n  return result;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}