{"ast":null,"code":"'use strict';\n\nconst path = require('path');\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\r\n * Creates a matcher function from one or more glob patterns. The\r\n * returned function takes a string to match as its first argument,\r\n * and returns true if the string is a match. The returned matcher\r\n * function also takes a boolean as the second argument that, when true,\r\n * returns an object with additional information.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch(glob[, options]);\r\n *\r\n * const isMatch = picomatch('*.!(*a)');\r\n * console.log(isMatch('a.a')); //=> false\r\n * console.log(isMatch('a.b')); //=> true\r\n * ```\r\n * @name picomatch\r\n * @param {String|Array} `globs` One or more glob patterns.\r\n * @param {Object=} `options`\r\n * @return {Function=} Returns a matcher function.\r\n * @api public\r\n */\n\nconst picomatch = function (glob, options) {\n  let returnState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n  const isState = isObject(glob) && glob.tokens && glob.input;\n  if (glob === '' || typeof glob !== 'string' && !isState) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);\n  const state = regex.state;\n  delete regex.state;\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = {\n      ...options,\n      ignore: null,\n      onMatch: null,\n      onResult: null\n    };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n  const matcher = function (input) {\n    let returnObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      isMatch,\n      match,\n      output\n    } = picomatch.test(input, regex, options, {\n      glob,\n      posix\n    });\n    const result = {\n      glob,\n      state,\n      regex,\n      posix,\n      input,\n      output,\n      match,\n      isMatch\n    };\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n  if (returnState) {\n    matcher.state = state;\n  }\n  return matcher;\n};\n\n/**\r\n * Test `input` with the given `regex`. This is used by the main\r\n * `picomatch()` function to test the input string.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.test(input, regex[, options]);\r\n *\r\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\r\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\r\n * ```\r\n * @param {String} `input` String to test.\r\n * @param {RegExp} `regex`\r\n * @return {Object} Returns an object with matching info.\r\n * @api public\r\n */\n\npicomatch.test = function (input, regex, options) {\n  let {\n    glob,\n    posix\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n  if (input === '') {\n    return {\n      isMatch: false,\n      output: ''\n    };\n  }\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = match && format ? format(input) : input;\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n  return {\n    isMatch: Boolean(match),\n    match,\n    output\n  };\n};\n\n/**\r\n * Match the basename of a filepath.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.matchBase(input, glob[, options]);\r\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\r\n * ```\r\n * @param {String} `input` String to test.\r\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\r\n * @return {Boolean}\r\n * @api public\r\n */\n\npicomatch.matchBase = function (input, glob, options) {\n  let posix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : utils.isWindows(options);\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\r\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.isMatch(string, patterns[, options]);\r\n *\r\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\r\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\r\n * ```\r\n * @param {String|Array} str The string to test.\r\n * @param {String|Array} patterns One or more glob patterns to use for matching.\r\n * @param {Object} [options] See available [options](#options).\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\r\n * Parse a glob pattern to create the source string for a regular\r\n * expression.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * const result = picomatch.parse(pattern[, options]);\r\n * ```\r\n * @param {String} `pattern`\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\r\n * @api public\r\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, {\n    ...options,\n    fastpaths: false\n  });\n};\n\n/**\r\n * Scan a glob pattern to separate the pattern into segments.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.scan(input[, options]);\r\n *\r\n * const result = picomatch.scan('!./foo/*.js');\r\n * console.log(result);\r\n * { prefix: '!./',\r\n *   input: '!./foo/*.js',\r\n *   start: 3,\r\n *   base: 'foo',\r\n *   glob: '*.js',\r\n *   isBrace: false,\r\n *   isBracket: false,\r\n *   isGlob: true,\r\n *   isExtglob: false,\r\n *   isGlobstar: false,\r\n *   negated: true }\r\n * ```\r\n * @param {String} `input` Glob pattern to scan.\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object with\r\n * @api public\r\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\r\n * Compile a regular expression from the `state` object returned by the\r\n * [parse()](#parse) method.\r\n *\r\n * @param {Object} `state`\r\n * @param {Object} `options`\r\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\r\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\r\n * @return {RegExp}\r\n * @api public\r\n */\n\npicomatch.compileRe = function (state, options) {\n  let returnOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let returnState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (returnOutput === true) {\n    return state.output;\n  }\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n  let source = `${prepend}(?:${state.output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n  return regex;\n};\n\n/**\r\n * Create a regular expression from a parsed glob pattern.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * const state = picomatch.parse('*.js');\r\n * // picomatch.compileRe(state[, options]);\r\n *\r\n * console.log(picomatch.compileRe(state));\r\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\r\n * ```\r\n * @param {String} `state` The object returned from the `.parse` method.\r\n * @param {Object} `options`\r\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\r\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\r\n * @return {RegExp} Returns a regex created from the given pattern.\r\n * @api public\r\n */\n\npicomatch.makeRe = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let returnOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let returnState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n  let parsed = {\n    negated: false,\n    fastpaths: true\n  };\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    parsed.output = parse.fastpaths(input, options);\n  }\n  if (!parsed.output) {\n    parsed = parse(input, options);\n  }\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\r\n * Create a regular expression from the given regex source string.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.toRegex(source[, options]);\r\n *\r\n * const { output } = picomatch.parse('*.js');\r\n * console.log(picomatch.toRegex(output));\r\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\r\n * ```\r\n * @param {String} `source` Regular expression source string.\r\n * @param {Object} `options`\r\n * @return {RegExp}\r\n * @api public\r\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\r\n * Picomatch constants.\r\n * @return {Object}\r\n */\n\npicomatch.constants = constants;\n\n/**\r\n * Expose \"picomatch\"\r\n */\n\nmodule.exports = picomatch;","map":{"version":3,"names":["path","require","scan","parse","utils","constants","isObject","val","Array","isArray","picomatch","glob","options","returnState","fns","map","input","arrayMatcher","str","isMatch","state","isState","tokens","TypeError","opts","posix","isWindows","regex","compileRe","makeRe","isIgnored","ignore","ignoreOpts","onMatch","onResult","matcher","returnObject","match","output","test","result","onIgnore","format","toPosixSlashes","capture","matchBase","basename","exec","Boolean","RegExp","patterns","pattern","p","fastpaths","returnOutput","prepend","contains","append","source","negated","toRegex","parsed","flags","nocase","err","debug","module","exports"],"sources":["D:/Documents/VS Code Projects/c2hd/c2hd/node_modules/picomatch/lib/picomatch.js"],"sourcesContent":["'use strict';\r\n\r\nconst path = require('path');\r\nconst scan = require('./scan');\r\nconst parse = require('./parse');\r\nconst utils = require('./utils');\r\nconst constants = require('./constants');\r\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\r\n\r\n/**\r\n * Creates a matcher function from one or more glob patterns. The\r\n * returned function takes a string to match as its first argument,\r\n * and returns true if the string is a match. The returned matcher\r\n * function also takes a boolean as the second argument that, when true,\r\n * returns an object with additional information.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch(glob[, options]);\r\n *\r\n * const isMatch = picomatch('*.!(*a)');\r\n * console.log(isMatch('a.a')); //=> false\r\n * console.log(isMatch('a.b')); //=> true\r\n * ```\r\n * @name picomatch\r\n * @param {String|Array} `globs` One or more glob patterns.\r\n * @param {Object=} `options`\r\n * @return {Function=} Returns a matcher function.\r\n * @api public\r\n */\r\n\r\nconst picomatch = (glob, options, returnState = false) => {\r\n  if (Array.isArray(glob)) {\r\n    const fns = glob.map(input => picomatch(input, options, returnState));\r\n    const arrayMatcher = str => {\r\n      for (const isMatch of fns) {\r\n        const state = isMatch(str);\r\n        if (state) return state;\r\n      }\r\n      return false;\r\n    };\r\n    return arrayMatcher;\r\n  }\r\n\r\n  const isState = isObject(glob) && glob.tokens && glob.input;\r\n\r\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\r\n    throw new TypeError('Expected pattern to be a non-empty string');\r\n  }\r\n\r\n  const opts = options || {};\r\n  const posix = utils.isWindows(options);\r\n  const regex = isState\r\n    ? picomatch.compileRe(glob, options)\r\n    : picomatch.makeRe(glob, options, false, true);\r\n\r\n  const state = regex.state;\r\n  delete regex.state;\r\n\r\n  let isIgnored = () => false;\r\n  if (opts.ignore) {\r\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\r\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\r\n  }\r\n\r\n  const matcher = (input, returnObject = false) => {\r\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\r\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\r\n\r\n    if (typeof opts.onResult === 'function') {\r\n      opts.onResult(result);\r\n    }\r\n\r\n    if (isMatch === false) {\r\n      result.isMatch = false;\r\n      return returnObject ? result : false;\r\n    }\r\n\r\n    if (isIgnored(input)) {\r\n      if (typeof opts.onIgnore === 'function') {\r\n        opts.onIgnore(result);\r\n      }\r\n      result.isMatch = false;\r\n      return returnObject ? result : false;\r\n    }\r\n\r\n    if (typeof opts.onMatch === 'function') {\r\n      opts.onMatch(result);\r\n    }\r\n    return returnObject ? result : true;\r\n  };\r\n\r\n  if (returnState) {\r\n    matcher.state = state;\r\n  }\r\n\r\n  return matcher;\r\n};\r\n\r\n/**\r\n * Test `input` with the given `regex`. This is used by the main\r\n * `picomatch()` function to test the input string.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.test(input, regex[, options]);\r\n *\r\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\r\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\r\n * ```\r\n * @param {String} `input` String to test.\r\n * @param {RegExp} `regex`\r\n * @return {Object} Returns an object with matching info.\r\n * @api public\r\n */\r\n\r\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\r\n  if (typeof input !== 'string') {\r\n    throw new TypeError('Expected input to be a string');\r\n  }\r\n\r\n  if (input === '') {\r\n    return { isMatch: false, output: '' };\r\n  }\r\n\r\n  const opts = options || {};\r\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\r\n  let match = input === glob;\r\n  let output = (match && format) ? format(input) : input;\r\n\r\n  if (match === false) {\r\n    output = format ? format(input) : input;\r\n    match = output === glob;\r\n  }\r\n\r\n  if (match === false || opts.capture === true) {\r\n    if (opts.matchBase === true || opts.basename === true) {\r\n      match = picomatch.matchBase(input, regex, options, posix);\r\n    } else {\r\n      match = regex.exec(output);\r\n    }\r\n  }\r\n\r\n  return { isMatch: Boolean(match), match, output };\r\n};\r\n\r\n/**\r\n * Match the basename of a filepath.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.matchBase(input, glob[, options]);\r\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\r\n * ```\r\n * @param {String} `input` String to test.\r\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\r\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\r\n  return regex.test(path.basename(input));\r\n};\r\n\r\n/**\r\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.isMatch(string, patterns[, options]);\r\n *\r\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\r\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\r\n * ```\r\n * @param {String|Array} str The string to test.\r\n * @param {String|Array} patterns One or more glob patterns to use for matching.\r\n * @param {Object} [options] See available [options](#options).\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\r\n\r\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\r\n\r\n/**\r\n * Parse a glob pattern to create the source string for a regular\r\n * expression.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * const result = picomatch.parse(pattern[, options]);\r\n * ```\r\n * @param {String} `pattern`\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\r\n * @api public\r\n */\r\n\r\npicomatch.parse = (pattern, options) => {\r\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\r\n  return parse(pattern, { ...options, fastpaths: false });\r\n};\r\n\r\n/**\r\n * Scan a glob pattern to separate the pattern into segments.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.scan(input[, options]);\r\n *\r\n * const result = picomatch.scan('!./foo/*.js');\r\n * console.log(result);\r\n * { prefix: '!./',\r\n *   input: '!./foo/*.js',\r\n *   start: 3,\r\n *   base: 'foo',\r\n *   glob: '*.js',\r\n *   isBrace: false,\r\n *   isBracket: false,\r\n *   isGlob: true,\r\n *   isExtglob: false,\r\n *   isGlobstar: false,\r\n *   negated: true }\r\n * ```\r\n * @param {String} `input` Glob pattern to scan.\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object with\r\n * @api public\r\n */\r\n\r\npicomatch.scan = (input, options) => scan(input, options);\r\n\r\n/**\r\n * Compile a regular expression from the `state` object returned by the\r\n * [parse()](#parse) method.\r\n *\r\n * @param {Object} `state`\r\n * @param {Object} `options`\r\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\r\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\r\n * @return {RegExp}\r\n * @api public\r\n */\r\n\r\npicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\r\n  if (returnOutput === true) {\r\n    return state.output;\r\n  }\r\n\r\n  const opts = options || {};\r\n  const prepend = opts.contains ? '' : '^';\r\n  const append = opts.contains ? '' : '$';\r\n\r\n  let source = `${prepend}(?:${state.output})${append}`;\r\n  if (state && state.negated === true) {\r\n    source = `^(?!${source}).*$`;\r\n  }\r\n\r\n  const regex = picomatch.toRegex(source, options);\r\n  if (returnState === true) {\r\n    regex.state = state;\r\n  }\r\n\r\n  return regex;\r\n};\r\n\r\n/**\r\n * Create a regular expression from a parsed glob pattern.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * const state = picomatch.parse('*.js');\r\n * // picomatch.compileRe(state[, options]);\r\n *\r\n * console.log(picomatch.compileRe(state));\r\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\r\n * ```\r\n * @param {String} `state` The object returned from the `.parse` method.\r\n * @param {Object} `options`\r\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\r\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\r\n * @return {RegExp} Returns a regex created from the given pattern.\r\n * @api public\r\n */\r\n\r\npicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\r\n  if (!input || typeof input !== 'string') {\r\n    throw new TypeError('Expected a non-empty string');\r\n  }\r\n\r\n  let parsed = { negated: false, fastpaths: true };\r\n\r\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\r\n    parsed.output = parse.fastpaths(input, options);\r\n  }\r\n\r\n  if (!parsed.output) {\r\n    parsed = parse(input, options);\r\n  }\r\n\r\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\r\n};\r\n\r\n/**\r\n * Create a regular expression from the given regex source string.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.toRegex(source[, options]);\r\n *\r\n * const { output } = picomatch.parse('*.js');\r\n * console.log(picomatch.toRegex(output));\r\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\r\n * ```\r\n * @param {String} `source` Regular expression source string.\r\n * @param {Object} `options`\r\n * @return {RegExp}\r\n * @api public\r\n */\r\n\r\npicomatch.toRegex = (source, options) => {\r\n  try {\r\n    const opts = options || {};\r\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\r\n  } catch (err) {\r\n    if (options && options.debug === true) throw err;\r\n    return /$^/;\r\n  }\r\n};\r\n\r\n/**\r\n * Picomatch constants.\r\n * @return {Object}\r\n */\r\n\r\npicomatch.constants = constants;\r\n\r\n/**\r\n * Expose \"picomatch\"\r\n */\r\n\r\nmodule.exports = picomatch;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}