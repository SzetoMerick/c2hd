{"ast":null,"code":"/*!\r\n * body-parser\r\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n\n'use strict';\n\n/**\r\n * Module dependencies.\r\n */\nvar bytes = require('bytes');\nvar debug = require('debug')('body-parser:raw');\nvar read = require('../read');\nvar typeis = require('type-is');\n\n/**\r\n * Module exports.\r\n */\n\nmodule.exports = raw;\n\n/**\r\n * Create a middleware to parse raw bodies.\r\n *\r\n * @param {object} [options]\r\n * @return {function}\r\n * @api public\r\n */\n\nfunction raw(options) {\n  var opts = options || {};\n  var inflate = opts.inflate !== false;\n  var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;\n  var type = opts.type || 'application/octet-stream';\n  var verify = opts.verify || false;\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function');\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;\n  function parse(buf) {\n    return buf;\n  }\n  return function rawParser(req, res, next) {\n    if (req._body) {\n      debug('body already parsed');\n      next();\n      return;\n    }\n    req.body = req.body || {};\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body');\n      next();\n      return;\n    }\n    debug('content-type %j', req.headers['content-type']);\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing');\n      next();\n      return;\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: null,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    });\n  };\n}\n\n/**\r\n * Get the simple type checker.\r\n *\r\n * @param {string} type\r\n * @return {function}\r\n */\n\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type));\n  };\n}","map":{"version":3,"names":["bytes","require","debug","read","typeis","module","exports","raw","options","opts","inflate","limit","parse","type","verify","TypeError","shouldParse","typeChecker","buf","rawParser","req","res","next","_body","body","hasBody","headers","encoding","checkType","Boolean"],"sources":["D:/Documents/VS Code Projects/c2hd/c2hd/node_modules/body-parser/lib/types/raw.js"],"sourcesContent":["/*!\r\n * body-parser\r\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\n'use strict'\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar bytes = require('bytes')\r\nvar debug = require('debug')('body-parser:raw')\r\nvar read = require('../read')\r\nvar typeis = require('type-is')\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = raw\r\n\r\n/**\r\n * Create a middleware to parse raw bodies.\r\n *\r\n * @param {object} [options]\r\n * @return {function}\r\n * @api public\r\n */\r\n\r\nfunction raw (options) {\r\n  var opts = options || {}\r\n\r\n  var inflate = opts.inflate !== false\r\n  var limit = typeof opts.limit !== 'number'\r\n    ? bytes.parse(opts.limit || '100kb')\r\n    : opts.limit\r\n  var type = opts.type || 'application/octet-stream'\r\n  var verify = opts.verify || false\r\n\r\n  if (verify !== false && typeof verify !== 'function') {\r\n    throw new TypeError('option verify must be function')\r\n  }\r\n\r\n  // create the appropriate type checking function\r\n  var shouldParse = typeof type !== 'function'\r\n    ? typeChecker(type)\r\n    : type\r\n\r\n  function parse (buf) {\r\n    return buf\r\n  }\r\n\r\n  return function rawParser (req, res, next) {\r\n    if (req._body) {\r\n      debug('body already parsed')\r\n      next()\r\n      return\r\n    }\r\n\r\n    req.body = req.body || {}\r\n\r\n    // skip requests without bodies\r\n    if (!typeis.hasBody(req)) {\r\n      debug('skip empty body')\r\n      next()\r\n      return\r\n    }\r\n\r\n    debug('content-type %j', req.headers['content-type'])\r\n\r\n    // determine if request should be parsed\r\n    if (!shouldParse(req)) {\r\n      debug('skip parsing')\r\n      next()\r\n      return\r\n    }\r\n\r\n    // read\r\n    read(req, res, next, parse, debug, {\r\n      encoding: null,\r\n      inflate: inflate,\r\n      limit: limit,\r\n      verify: verify\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * Get the simple type checker.\r\n *\r\n * @param {string} type\r\n * @return {function}\r\n */\r\n\r\nfunction typeChecker (type) {\r\n  return function checkType (req) {\r\n    return Boolean(typeis(req, type))\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC5B,IAAIC,KAAK,GAAGD,OAAO,CAAC,OAAO,CAAC,CAAC,iBAAiB,CAAC;AAC/C,IAAIE,IAAI,GAAGF,OAAO,CAAC,SAAS,CAAC;AAC7B,IAAIG,MAAM,GAAGH,OAAO,CAAC,SAAS,CAAC;;AAE/B;AACA;AACA;;AAEAI,MAAM,CAACC,OAAO,GAAGC,GAAG;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,GAAG,CAAEC,OAAO,EAAE;EACrB,IAAIC,IAAI,GAAGD,OAAO,IAAI,CAAC,CAAC;EAExB,IAAIE,OAAO,GAAGD,IAAI,CAACC,OAAO,KAAK,KAAK;EACpC,IAAIC,KAAK,GAAG,OAAOF,IAAI,CAACE,KAAK,KAAK,QAAQ,GACtCX,KAAK,CAACY,KAAK,CAACH,IAAI,CAACE,KAAK,IAAI,OAAO,CAAC,GAClCF,IAAI,CAACE,KAAK;EACd,IAAIE,IAAI,GAAGJ,IAAI,CAACI,IAAI,IAAI,0BAA0B;EAClD,IAAIC,MAAM,GAAGL,IAAI,CAACK,MAAM,IAAI,KAAK;EAEjC,IAAIA,MAAM,KAAK,KAAK,IAAI,OAAOA,MAAM,KAAK,UAAU,EAAE;IACpD,MAAM,IAAIC,SAAS,CAAC,gCAAgC,CAAC;EACvD;;EAEA;EACA,IAAIC,WAAW,GAAG,OAAOH,IAAI,KAAK,UAAU,GACxCI,WAAW,CAACJ,IAAI,CAAC,GACjBA,IAAI;EAER,SAASD,KAAK,CAAEM,GAAG,EAAE;IACnB,OAAOA,GAAG;EACZ;EAEA,OAAO,SAASC,SAAS,CAAEC,GAAG,EAAEC,GAAG,EAAEC,IAAI,EAAE;IACzC,IAAIF,GAAG,CAACG,KAAK,EAAE;MACbrB,KAAK,CAAC,qBAAqB,CAAC;MAC5BoB,IAAI,EAAE;MACN;IACF;IAEAF,GAAG,CAACI,IAAI,GAAGJ,GAAG,CAACI,IAAI,IAAI,CAAC,CAAC;;IAEzB;IACA,IAAI,CAACpB,MAAM,CAACqB,OAAO,CAACL,GAAG,CAAC,EAAE;MACxBlB,KAAK,CAAC,iBAAiB,CAAC;MACxBoB,IAAI,EAAE;MACN;IACF;IAEApB,KAAK,CAAC,iBAAiB,EAAEkB,GAAG,CAACM,OAAO,CAAC,cAAc,CAAC,CAAC;;IAErD;IACA,IAAI,CAACV,WAAW,CAACI,GAAG,CAAC,EAAE;MACrBlB,KAAK,CAAC,cAAc,CAAC;MACrBoB,IAAI,EAAE;MACN;IACF;;IAEA;IACAnB,IAAI,CAACiB,GAAG,EAAEC,GAAG,EAAEC,IAAI,EAAEV,KAAK,EAAEV,KAAK,EAAE;MACjCyB,QAAQ,EAAE,IAAI;MACdjB,OAAO,EAAEA,OAAO;MAChBC,KAAK,EAAEA,KAAK;MACZG,MAAM,EAAEA;IACV,CAAC,CAAC;EACJ,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASG,WAAW,CAAEJ,IAAI,EAAE;EAC1B,OAAO,SAASe,SAAS,CAAER,GAAG,EAAE;IAC9B,OAAOS,OAAO,CAACzB,MAAM,CAACgB,GAAG,EAAEP,IAAI,CAAC,CAAC;EACnC,CAAC;AACH"},"metadata":{},"sourceType":"script","externalDependencies":[]}